{
    "success": true,
    "data": [
        {
            "id": "5a2403226190c8912ebaceeb",
            "author_id": "4f447c2f0a8abae26e01b27d",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FhSNYCv6Ab9wzT6aUSfKLa0GtP4w\" alt=\"image.png\"></p>\n<blockquote>\n<p>原文地址：知乎专栏 <a href=\"https://zhuanlan.zhihu.com/p/31640541\">https://zhuanlan.zhihu.com/p/31640541</a></p>\n</blockquote>\n<p>给大家介绍下，Egg 2.0 正式版，今天 12.3 冒泡啦，距 3.21 的 <a href=\"https://zhuanlan.zhihu.com/p/25860846\">Egg 1.0 版本</a> 时隔 8 个月。</p>\n<p><img src=\"//dn-cnode.qbox.me/FrC_ZbrhyLkhVIquPOsMqPhvqsHX\" alt=\"image.png\"></p>\n<blockquote>\n<p><a href=\"https://eggjs.org/\">Egg</a> 是阿里 Node.js 的核心基础框架，面向『企业级的 Web 基础框架』这个领域，提供了「微内核 + 插件机制 + 框架定制能力」，完美达成生态共建和差异化定制的平衡点。<br>\n既适合个人小项目快速开发，也适合团队架构师基于自身的技术架构在 Egg 基础上扩展出适合特定团队业务场景的框架。<br>\n它沉淀自阿里在各行各业不同领域的大规模工程实践经验，稳定支撑了多年天猫双11大促，顶级流量压力。</p>\n</blockquote>\n<h2>2.0 特性</h2>\n<ul>\n<li>基于 Koa 2.x\n<ul>\n<li>异步解决方案直接基于 Async Function 。</li>\n<li>去除 co 兼容后<a href=\"https://github.com/eggjs/egg/wiki/co-vs-async\">堆栈信息更清晰</a>。</li>\n</ul>\n</li>\n<li>框架层优化带来 <a href=\"https://eggjs.github.io/benchmark/plot/\">30% 左右的性能提升</a>，不含 Node 8 带来的提升。</li>\n<li>为了方便开发者快速升级，保持了对 Egg 1.x 以及 generator function 的兼容。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fuf5DkXMxM7wfClcN6B6LzX5d18Q\" alt=\"image.png\"></p>\n<h2>如何升级</h2>\n<p><strong><a href=\"https://eggjs.org/\">Egg</a> 的理念之一是渐进式增强，故我们为开发者提供渐进升级的体验。</strong></p>\n<ol>\n<li>Node.js 使用最新的 LTS 版本（&gt;=8.9.0）。</li>\n<li>修改 package.json 中 egg 的依赖为 ^2.0.0。</li>\n<li>检查相关插件是否发布新版本（可选）。</li>\n<li>重新安装依赖，跑单元测试。</li>\n</ol>\n<p><strong>搞定！几乎不需要修改任何一行代码，就已经完成了升级。</strong></p>\n<p>这得益于 Egg 对 1.x 的兼容，但为了更好的统一代码风格，以及更佳的性能和错误堆栈，我们建议开发者参考 <a href=\"https://eggjs.org/zh-cn/migration.html\">升级指南</a> 进一步升级。</p>\n<h2>未来规划</h2>\n<p>如您所知，Egg 采用的是 <strong>『微内核 + 插件 + 上层框架』</strong> 模式。</p>\n<p>其中微内核经过 3 年 4 个版本，以及在阿里的大规模应用，已经打磨的非常稳定。</p>\n<p>接下来我们的<strong>重心主要在开发者体验方面的优化</strong>，包括：</p>\n<ul>\n<li>更好的开发者体验，包括 TypeScript，开发者工具，IDE 工具等方面。</li>\n<li>社区扶持\n<ul>\n<li>协助业界的前端团队，打造适合特定团队业务场景的上层框架，欢迎勾搭。</li>\n<li>分享我们在团队、协作、规范化等方面的经验。</li>\n<li>分享在 Docker，GraphQL，SSR 等方面的探索和最佳实践分享。</li>\n</ul>\n</li>\n<li>国际化，官网和<a href=\"https://github.com/eggjs/egg/issues/363\">文档翻译</a>等。</li>\n</ul>\n<p>同时，我们也欢迎社区更多的<a href=\"https://github.com/orgs/eggjs/projects\">参与</a>，一起打造更完善的生态。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fg_WHGNC13j2azgEWb-ONk5whle5\" alt=\"image.png\"></p>\n<h2>我们这一年</h2>\n<p>截止至今天(2017-12-03)：</p>\n<ul>\n<li><strong>GitHub 5.6k star</strong>，555 forks，npm 月下载量 11,140 (不含阿里内网数据)。</li>\n<li>从 1.0 到 2.0，我们一共发布了 <a href=\"https://github.com/eggjs/egg/releases\">18 个版本</a>，处理了 820 个 issue，收到了 500+ (主库 272) 个 Pull Request 。</li>\n<li>开发者体验方面的优化包括：<a href=\"https://eggjs.org/zh-cn/core/development.html#%E4%BD%BF%E7%94%A8-egg-bin-%E8%B0%83%E8%AF%95\">断点调试代理</a>，<a href=\"https://eggjs.org/zh-cn/core/development.html#%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95\">单元测试+覆盖率</a>，<a href=\"https://eggjs.org/zh-cn/core/deployment.html#%E9%83%A8%E7%BD%B2\">部署工具</a>，TypeScript 支持，<a href=\"https://github.com/eggjs/vscode-eggjs\">VSCode 插件</a>，文档优化等等。</li>\n</ul>\n<p><strong>社区方面：</strong></p>\n<ul>\n<li>来自 BAT，丁香园，全民直播等多家兄弟公司的反馈和插件回馈。</li>\n<li>来自 <a href=\"https://github.com/eggjs/egg/network/dependents\">GitHub Dependents</a> 的统计：992 Repositories, 231 Packages</li>\n<li><a href=\"https://npms.io/search?q=egg-\">NPM 搜索结果</a>超过 400 个。</li>\n<li>上层框架：\n<ul>\n<li><a href=\"https://github.com/alibaba/beidou\">北斗</a> - Isomorphic framework for server-rendered React apps</li>\n<li><a href=\"https://github.com/avetjs/avet\">avet</a> - A very comfortable framework for writing isomorphic applications</li>\n</ul>\n</li>\n<li>如果你有好的分享，PR 传送门：<a href=\"https://github.com/eggjs/awesome-egg\">awesome-egg</a></li>\n</ul>\n<p><strong>趣味数据：</strong></p>\n<ul>\n<li>官网访问量中，Mac 占 47% → 这比例挺高的，看来 Node 程序猿都很幸福。</li>\n<li>周末的访问量约为平时的 1/3 → 看来 Node 程序猿周末加班少。（滑稽</li>\n<li>官网访问来源：站内，直链，外链各 30% 多，来自搜索引擎的较少。</li>\n</ul>\n<p><strong>分享交流：</strong></p>\n<ul>\n<li>在 <a href=\"http://2017.jsdc.tw/\">台灣 JSDC2017 開發者年會</a> 和 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了『<a href=\"https://github.com/atian25/blog/raw/master/assets/files/Egg%20%26%20Node.js%20%E4%BB%8E%E5%B0%8F%E5%B7%A5%E5%9D%8A%E8%B5%B0%E5%90%91%E4%BC%81%E4%B8%9A%E7%BA%A7%E5%BC%80%E5%8F%91.pdf\">Egg &amp; Node.js 从小工坊走向企业级开发</a>』</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/FgFUrGpNw07LKQPYzGgZp64j7CZH\" alt=\"image.png\"></p>\n<ul>\n<li>Node TSC @张秋怡 在 <a href=\"https://nina17.sched.com/event/Atii/nodejs-at-alibaba-a-joyee-cheung-alibaba-cloud\">Node Interactive North America 2017</a> 和 <a href=\"http://nodefest.jp/2017/schedule.html#joyee\">東京Node学園祭2017</a> 分享了『<a href=\"https://github.com/joyeecheung/talks/blob/master/node_fest_2017/nodejs_at_alibaba_tokyo.pdf\">Node.js at Alibaba</a>』。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fl5IyrfAMzQ49Uz3eQ67i2FLL09H\" alt=\"image.png\"></p>\n<ul>\n<li><a href=\"/user/ngot\">@ngot</a> 在 <a href=\"https://www.bagevent.com/event/751307\">Node Party</a> 分享了『<a href=\"https://github.com/Hangzhou-Node-Party/Node-Party/blob/master/2017-08-19/Egg.js%E5%9C%A8%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4%E9%9B%86%E5%9B%A2%E7%9A%84%E7%9A%84%E5%AE%9E%E8%B7%B5%E8%BF%90%E7%94%A8.pdf\">Egg.js 在阿里巴巴集团的实践运用</a>』</li>\n<li>@姜天意 在 <a href=\"http://2017.imweb.io/index.html#schedule\">腾讯IMWebConf</a> 分享了 『<a href=\"https://github.com/jtyjty99999/share/blob/master/security%20risk%20in%20node%20web.pdf\">脆弱的 Node.js</a>』</li>\n</ul>\n<h2>写在最后</h2>\n<p>开源，痛并快乐着。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fiamh5LNYR3e2E0HtdhrO3sVfHrs\" alt=\"image.png\"></p>\n</div>",
            "title": "企业级 Node.js 框架 Egg 发布 2.0，性能提升 30%，拥抱 Async",
            "last_reply_at": "2018-01-29T02:54:03.631Z",
            "good": true,
            "top": true,
            "reply_count": 104,
            "visit_count": 18236,
            "create_at": "2017-12-03T13:58:58.901Z",
            "author": {
                "loginname": "atian25",
                "avatar_url": "https://avatars1.githubusercontent.com/u/227713?v=3&s=120"
            }
        }, {
            "id": "5a54a8a4afa0a121784a8ab0",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>很抱歉在首届蚂蚁体验科技 SEE Conf 大会上，给大家讲得有点磕绊不太清楚。今天写下来行诸文字，希望一些思考能与大家进一步交流。（设计师朋友可以跳过前端技术部分，直接看后面章节）</p>\n<h2>什么是前端技术</h2>\n<p>第一次接触前端开发是 2002 年大学期间，转眼 15 年多。这些年一直在思考一个问题：究竟什么是前端技术？很长很长一段时间，前端技术的定义非常清晰，就是浏览器端的 HTML、CSS、JS 技术。我们用这些技术做出各种各样的页面，我们是离用户最近的程序员。</p>\n<p><img src=\"//dn-cnode.qbox.me/FuTZzCUKkL_OGOsmrXbXvcqalO-D\" alt=\"v2-356e4bb976792ec0c2ae166405e4b502_hd.jpg\"></p>\n<p>记得 2009 年开始接触 Node，很快前端技术开始爆炸性增长。最开始的变化，是前端压缩工具从基于 Java 的 YUI Compressor 开始切换到基于 Node 实现的 UglifyJS 等工具。除了前端工具上的一路狂奔，在服务端领域也出现了 Express 等框架，前端开始通过 Node 完成服务端模板甚至整个 MVC 层的开发。在蚂蚁金服，服务端层我们更多把 Node 定位为 BFF 层实现，BFF 是 Backend For Frontend 的缩写，翻译成用户体验适配层。</p>\n<p>BFF 模式下，整体分工很清晰，后端通过 Java 等语言负责服务实现，理想情况下给前端提供的是基于领域模型的 RPC 接口，前端则在 BFF 层直接调用服务端 RPC 接口拿到数据，按需加工消费数据，并实现人机交互。基于 BFF 模式的研发，很适合拥有前端技术背景的全栈型工程师。这种模式的好处很明显，后端可以专注于业务领域，更多从领域模型的视角去思考问题，页面视角的数据则交给前端型全栈工程师去搞定。领域模型与页面数据是两种思维模式，通过 BFF 可以很好地解耦开，让彼此更专业高效。</p>\n<p>除了服务端的渗透，从 2013 年开始，阿里开始无线 ALL IN 战略，这对前端影响非常大。有相当多的前端开始转型为 iOS 工程师（转型为 Android 的比较少，有部分 Java 工程师转型成了 Android 开发），没有转型的，也开始大量投入到 Mobile Web 开发。这个大背景下，前端与客户端技术开始互相融合，特别是在容器层。从 2015 年开始，物联网 IoT 逐步兴起，前端开始涉足 IoT 设备上的应用研发。端的本质是 devices，台式机、手机、IoT 设备都是一台台 devices，很多会直接被用户使用，有用户使用的 devices，就会有人机交互需求，就会有前端的工作价值。前端是离用户最近的工程师，这个定位一直没变。</p>\n<p>非常有意思的是，在移动端的架构里，这几年也出现了基于 RPC 接口 + 网关 + BFF 的架构体系，在研发效率、网络性能等方面均有优势。随着 IoT 应用的涌现与复杂化，我相信最终也会出现 BFF 架构。BFF 模式不仅仅是一种技术架构，从社会分工角度讲，BFF 更是一种多元价值导向的分层架构，每一层都有不错的空间去施展，不仅能发挥工业社会双手的作用，还能使用上双手上面的脑袋。齿轮不再是被动跟着转，而是开始拥有自驱的转动力。同一时期，业界也出现了一些类似的职业融合。比如 DevOps 倡导开发也懂运维，不少大公司在推行开发也懂测试，测试则转型为更专业的质量工具部门，还有前端也懂设计的 DesignOps 的出现等等。各种全栈概念的涌现，都是在重新探索更合理的分层协作模式。纷纷扰扰，成败如风。</p>\n<p>补充一个说明，当年提出的前后端分离，并不准确，这些年一直努力纠正为前后端分层的理念。专业的分工协同对效能的提升很关键。全栈的含义是指分层演化后，每一层的技术栈要求，是每一层横向技能的全，而不是纵向跨层的通（纵向跨多层都能通的人才非常少，就如当今社会已经非常难诞生博物学家了）。不断探索更好的分层协作是有意思的，这就如人类家庭里夫妻的关系一样，男权、女权都不可取，社会的演化最终会视人为人，每个个体平等、自由，社会会以一种必然的不可阻挡的形态往前演进。</p>\n<p>回到前端发展历史，前面说了这么多，只说了一件事，前后端分层协作的各种模式。协作的边界是数据，后端提供数据服务接口，前端消费数据实现人机交互。不同模式下，BaaS（Backend as a Service）的含义各有不同。在 BFF 模式下，由于 BFF 层的运维部署需要，前端还需负责 BFF 层的 PaaS 平台建设。不同模式下的工程体系各有不同，工程的本质是让一群人做好一堆事，涉及代码规范、协作流程、运维部署、性能与安全等很多领域，这里不再一一展开。</p>\n<p>服务端 Node 与各种终端的涌现，让前端进入了大前端范畴，这时候的前端，已远远不只是浏览器端的页面实现技术，而是后端服务与人机界面的连接器。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fgj5HsTiql9rambFQbhDg8t49tw3\" alt=\"v2-374230208f31483237155e80d46f1c0d_hd.jpg\"></p>\n<h2>什么是体验科技</h2>\n<p>我属于无线 ALL IN 战略中，选择留下来继续做 PC Web 的前端。虽然公司重点转向无线，但 PC 业务一直没停。随着近几年整个阿里集团“大中台、小前台”的策略，越来越多的企业级中后台产品处于兵荒马乱阶段，设计师非常缺失，随手一抓，都是大量体验比较糟心的产品。这过程中，越来越感觉什么地方有问题，一定在某些点上我们没做好。当时没多想，就想着既然缺设计师，我们就尝试去招聘。于是体验技术部开始拥有了设计师，非常艰辛的起步，非常感激的是，虽然艰辛，但找到了一些与我一样坚信中后台产品价值的设计师。一旦有了设计师，整个中后台产品的用户体验，一下子就提升上来了。</p>\n<p><img src=\"//dn-cnode.qbox.me/FvNAdF0m7cCZlevYQDFThuRYxvbz\" alt=\"v2-54abf60cd133916e016343ae4adaf376_hd.jpg\"></p>\n<p>设计团队的融入，日常的各种碰撞交流，让我的思维发生了很大变化。前端技术再牛，都很难直接解决产品层的用户体验。对中后台产品来说，设计的价值也远远不止于让产品的颜值提升，设计的更多更多价值，在于深入到产品的业务逻辑里去，去帮助业务梳理产品信息架构与任务流程。用户体验是一个非常综合的事，需要各种专业人士在同一个产品上聚焦发力，一起共同努力才能真正提升产品体验。设计师在这个过程中很痛苦，很多中后台产品都是非常垂直领域的业务产品，中间件、ECS、ODPS 等一堆堆专业术语让设计师们痛苦不堪，幸运的是，我们扛了过来。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fk5n__QHurYmZawYh6-UXJ5Ox0Tv\" alt=\"v2-9b693a1affab86f96e24e0bee03b3e90_hd.jpg\"></p>\n<p>接下来的故事，在今天各个讲师的分享里，不少都有提及。整个团队的重心，开始非常清晰地往几个方向发展：</p>\n<ul>\n<li>TWA 方向：这是比 BFF 更大的概念，上午不四的分享里有详细阐述，可参考 知乎专栏文章 。TWA 是 Techless Web App 的缩写，是一种技术理念，希望越来越多的开发者，可以不用再关注流程、构建、环境、部署等各种事，希望能做到技术无感化（Techless），让每一位开发着能安安静静的快乐编码。</li>\n<li>UI 智能化方向：Ant Design 是一个设计体系，antd 是 Ant Design 的 React 实现。这几年 antd 的发展，不仅让前端编码更快更爽了，同时让一个历史悠久但生生不息的领域重燃希望：是否存在人机交互界面智能可视化搭建的可能？这个领域，这一两年在阿里内部非常火，各种搭建产品层出不穷，目前都还处于比较垂直的领域，泛化到行业级通用的产品还没怎么出现。我们也开始尝试，而且我们相信天时地利人和，一定能折腾出点什么，正在努力中，或许在下次 SEE Conf 大会中会展示给大家。</li>\n<li>数据可视化方向：下午绝云和御术的分享，相信大家对 G2 和 AntV 已经有了一个整体了解。可视化方向我们是从 2014 年开始正式投入人员去做，最开始的想法来自科幻片，大家如果喜欢看科幻片的话，会留意到各种人机交互界面都是各种可视化效果了，很少很少有传统网页。可视化是个历史非常悠久的领域，我们小学时学会的乘法竖式，就是一种可视化，可以帮助我们减少记忆成本，同时提升计算速度。</li>\n<li>图形互动化方向： 上午好修和景夫有分享，这一块才开始一年多，是我们非常笃定的一个方向。很多小孩，对书本都比较抗拒，但对游戏有着天生的喜爱。蚂蚁森林让大家从表单形式的公益，变成了互动游戏型的公益。越来越多的人机交互形式，会是有互动交互的图形界面。应用的泛互动化，是一个很大趋势。支付宝是个生活服务平台，各种生活服务的互动有趣化，一定是更有吸引力的。</li>\n</ul>\n<p><img src=\"//dn-cnode.qbox.me/Fui53ymFhJc0JS0IA0ZXqUvBNFiQ\" alt=\"v2-6830ebf2ca603dca8bd33723d73220e3_hd.jpg\"></p>\n<p>看更远的未来，我相信对体验科技来说，自然化和虚拟化会是两个大趋势。</p>\n<p>我现在在分享这个 PPT，要翻页时，需要点击键盘按钮，为什么电脑不能直接理解我的意图而自动翻页呢？比如我只要头往下示意一下，就能自然而然翻到下一页。我们现在很多行为，跳脱出来看，能发现很多很多不自然。天猫精灵等各种智能音箱，真正去用时，离自然交互还有比较远的距离。Ant Design 设计价值观里，最最重要的就是自然价值观，一切才刚刚开始探索。</p>\n<p>再说虚拟化。虚拟化不仅仅指 AR、VR 等技术，看过黑客帝国、西部世界等科幻片的，会对虚拟化有更多体感。如果以后每个小孩出生时，就会被植入一个能五感俱全的芯片，这种情况下，我们的人机交互会是怎么样的。太多可能性与挑战在等着我们。</p>\n<p>这一切都是体验科技，是技术与设计的融合，是服务与用户连接，是下图中的一个公式。</p>\n<p><img src=\"//dn-cnode.qbox.me/Fh5rgc3RVIRYuQYZSXMdKlBKlfnB\" alt=\"v2-773def061a6dd38cd97c52f040da29cc_hd.jpg\"></p>\n<p><img src=\"//dn-cnode.qbox.me/FpueJ6H7sBiB7kVsLORMYQpjDClK\" alt=\"v2-e4186cd37a1f978abbf64970dee50ba9_hd.jpg\"></p>\n<p>体验科技是 UX = f(services) 这个公式，能将各种各种的 services（后端服务） 通过技术与设计的融合，转变成体验一流的用户产品。这个公式的一个实现，就是蚂蚁体验云。蚂蚁体验云的初心，是希望能帮助有梦想的你，将一个个优秀的想法，通过体验云实现成一个个终端产品。\n<img src=\"//dn-cnode.qbox.me/FjtnnNqNeyh5rH4MTreunWUgsNgj\" alt=\"v2-ab3eae986630f436d1c6b751f4a8d895_hd.jpg\"></p>\n<p>体验云才刚刚起步，目前已在内部服务蚂蚁金服、阿里巴巴集团，同时快速孵化出了云凤蝶、语雀、小钱袋等创新产品。虽然还很不完善，但我们希望能尽快与用户一起成长。很多激动人心的事正在发生，通过体验科技的开放，我们希望着能为世界带来更多平等的机会。\n<img src=\"//dn-cnode.qbox.me/FgGx0MFi9k0eJAeLX3icMz6YLD9v\" alt=\"v2-98323a7d1c563df55151451066a7709e_hd.jpg\"></p>\n<p>感谢聆听，期待交流。</p>\n<p>附 SEE Conf 演讲视频： <a href=\"http://v.youku.com/v_show/id_XMzMwMzg2MDIwOA==.html\">优酷地址 </a></p>\n<p>最后，演讲 PPT 已精心整理并转换为 PDF 上传至<a href=\"http://yuque.com/seeconf\"> SEE Conf 语雀在线知识库</a>，欢迎下载（请 注册语雀，个人描述内注明 #知乎seeconf# 便可快速申请邀请码，登录后即可下载）</p>\n</div>",
            "title": "玉伯《从前端技术到体验科技（附演讲视频）》",
            "last_reply_at": "2018-01-24T06:49:43.526Z",
            "good": false,
            "top": true,
            "reply_count": 18,
            "visit_count": 6086,
            "create_at": "2018-01-09T11:33:56.183Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
            }
        }, {
            "id": "592917b59e32cc84569a7458",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>本来提供开发api，目的是为了开发第三方应用或客户端，如果大家用来学习也是好的，但现在很多人太过分了，随意发帖，at，严重影响了社区的用户，故而决定开始严查</p>\n<p>以下情况，直接封号</p>\n<ul>\n<li>测试标题</li>\n<li>无任何内容</li>\n<li>无意义回复</li>\n<li>测试帖，5分钟内没有删除</li>\n</ul>\n<p>欢迎大家监督</p>\n<p>封号</p>\n<ul>\n<li><a href=\"https://cnodejs.org/user/Mwangzhi\">https://cnodejs.org/user/Mwangzhi</a></li>\n<li><a href=\"https://cnodejs.org/user/lw6395\">https://cnodejs.org/user/lw6395</a></li>\n<li><a href=\"https://cnodejs.org/user/shengliang74\">https://cnodejs.org/user/shengliang74</a>  竟然挑衅，发帖说你来打我呀。。。。</li>\n<li><a href=\"https://cnodejs.org/user/h5-17\">https://cnodejs.org/user/h5-17</a> <a href=\"/user/h5-17\">@h5-17</a></li>\n<li><a href=\"https://cnodejs.org/user/592php\">https://cnodejs.org/user/592php</a> <a href=\"/user/592php\">@592php</a></li>\n</ul>\n<hr>\n<p>20170601更新</p>\n<p><a href=\"https://cnodejs.org/?tab=dev\">https://cnodejs.org/?tab=dev</a>  目前开了一个『客户端测试』专区，以后开发新客户端的同学，帖子直接发到这个专区去。tab 的值是 dev。</p>\n<p><img src=\"//dn-cnode.qbox.me/FundjyBuYk60yqQ-PdKstrPKY-7-\" alt=\"image.png\"></p>\n</div>",
            "title": "测试请发到客户端测试专区，违规影响用户的，直接封号",
            "last_reply_at": "2018-01-03T15:43:22.119Z",
            "good": false,
            "top": true,
            "reply_count": 147,
            "visit_count": 37479,
            "create_at": "2017-05-27T06:07:49.278Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
            }
        }, {
            "id": "5a6f16f79d371d4a059eef8a",
            "author_id": "59fbcfd75e33e3bb7496e7f6",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>自己个人的小项目, 主要想监测下 response time, 资源消耗等情况, Datadog 和 OneAPM 老大哥都是收费的, 没必要上,\n或者有开源的替代品么 ?</p>\n<p>老哥们推荐一波 ~</p>\n<p>:D</p>\n</div>",
            "title": "Node AMP 性能检测工具求推荐 ~",
            "last_reply_at": "2018-01-29T12:43:35.486Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 2,
            "create_at": "2018-01-29T12:43:35.486Z",
            "author": {
                "loginname": "iShawnWang",
                "avatar_url": "https://avatars0.githubusercontent.com/u/20266594?v=4&s=120"
            }
        }, {
            "id": "5a69e59e9288dc81532881ee",
            "author_id": "589ac689f46268be08aea5d6",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>之前是做前端的，主要写React。年前跳槽到公司做Node后端。刚入职两天手头还没有什么任务，请问刚开始主要学哪些东西，才能完成前端到后端的一个过渡和思维的转变。</p>\n</div>",
            "title": "前端转Node后端，刚入职，要注意哪些方面",
            "last_reply_at": "2018-01-29T12:07:06.460Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 438,
            "create_at": "2018-01-25T14:11:42.530Z",
            "author": {
                "loginname": "chaohangz",
                "avatar_url": "https://avatars2.githubusercontent.com/u/15074003?v=4&s=120"
            }
        }, {
            "id": "5a6e1d569d371d4a059eef41",
            "author_id": "503a6618f767cc9a5104139c",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FvDiF-U9QKBZu_Es1cpg0hlFNoAc\" alt=\"屏幕快照 2018-01-29 上午2.45.30.png\"></p>\n<p>GraphQL 既是一种用于 API 的查询语言也是一个满足你数据查询的运行时。 GraphQL 对你的 API 中的数据提供了一套易于理解的完整描述，使得客户端能够准确地获得它需要的数据，而且没有任何冗余。</p>\n<p>想更多的了解或使用 GraphQL，请访问 <a href=\"https://github.com/facebook/graphql\">https://github.com/facebook/graphql</a></p>\n<p>GraphQL 有针对不同语言的服务端实现，以帮助开发人员搭建 <code>GraphQL Server</code>。</p>\n<p>而 <code>gq-loader</code> 是一个 <code>webpack</code> 插件，你可以认为它一针对前端项目的一种 <code>client</code> 端实现，它的目的是帮助前端开发同学更简便的调用 GraphQL API，它让前端开发人员在使用 GraphQL 时更加方便，像普通 <code>js</code> 模块一样轻松自如，使前端开发人员能在 <code>js</code> 文件中通过 <code>import</code> 或 <code>require</code> 导入 <code>.gql</code> 和 <code>.graphql</code> 文件，然后直接调用。 并且它还支持通过 <code>#import</code> 语法导入其它 <code>.gql</code> 文件，比如 fragments。</p>\n<blockquote>\n<p><code>#import</code> 还提供了两个别名，分别是 <code>#require</code> 和 <code>#include</code>，这两个别名和 <code>#import</code> 的用法及行为完全一致。</p>\n</blockquote>\n<p><strong>关注或使用 <code>gq-loader</code></strong>，请移步 GitHub：<a href=\"https://github.com/Houfeng/gq-loader\">https://github.com/Houfeng/gq-loader</a></p>\n<h2>安装</h2>\n<pre class=\"prettyprint\"><code>npm install gq-loader --save-dev\n</code></pre><p>或者</p>\n<pre class=\"prettyprint\"><code>yarn add gq-loader\n</code></pre><h2>基本使用</h2>\n<p>如同其它类的的 loader 一样，首先，我们在 <code>webpack.config.js</code> 中添加 <code>gq-loader</code> 的配置</p>\n<pre class=\"prettyprint language-js\"><code>{\n  test: &#x2F;\\.(graphql|gql)$&#x2F;,\n  exclude: &#x2F;node_modules&#x2F;,\n  use: {\n    loader: &#x27;gq-loader&#x27;\n    options: {\n      url: &#x27;Graphql Server URL&#x27;\n    }\n  }\n}\n</code></pre><p>然后，我们就可以在 <code>js</code> 文件中通过 <code>import</code> 来导入 <code>.gql</code> 文件使用它了，我们来一个简单的示例，假设已经有一个可以工作的 <code>Graphql Server</code>，那么，我们先创建一个可以查询用户的 <code>getUser.gql</code></p>\n<pre class=\"prettyprint language-gql\"><code>#import &#x27;.&#x2F;fragment.gql&#x27; \n\nquery MyQuery($name: String) {\n  getUser(name: $name)\n    ...userFields\n  }\n}\n</code></pre><p>可以看到，我们通过 <code>#import</code> 引用了另外一个 <code>.gql</code> 文件 <code>fragment.gql</code>，在这个文件中我们描术了要返回的 user 的字段信息，这样我们就能在不同的地方「重用」它了，我们也创建一下这个文件</p>\n<pre class=\"prettyprint language-gql\"><code>fragment userFields on User {\n  name\n  age\n}\n</code></pre><p>好了，我们可以在 <code>js</code> 文件中直接导入 <code>getUser.gql</code>，并且使用它查询用户了，从未如此简便，我们来看看</p>\n<pre class=\"prettyprint language-js\"><code>import getUser from &#x27;.&#x2F;getUser.gql&#x27;;\nimport React from &#x27;react&#x27;;\nimport ReactDOM from &#x27;react-dom&#x27;;\n\nasync function query() {\n  const user = await getUser({ name: &#x27;bob&#x27; });\n  console.log(&#x27;user&#x27;, user);\n}\n\nfunction App() {\n  return &lt;button onClick={query}&gt;click&lt;&#x2F;button&gt;;\n}\n\nReactDOM.render(&lt;App &#x2F;&gt;, document.getElementById(&#x27;root&#x27;));\n</code></pre><p>在调用 <code>getUser</code> 时，我们可以通过参数，向 <code>GraphQL</code> 传递变量，这些变量就是我们的查询参数。</p>\n<h2>自定义请求</h2>\n<p>默认 <code>gq-loader</code> 就会帮你完成 <code>graphql 请求</code>，但某些场景下或许你想自已控制所有请求，如果有这样需要，我们还可以通过 <code>request</code> 属性来「自定义」请求，看一下示例，需要先稍微改动一下 <code>loader 配置</code></p>\n<pre class=\"prettyprint language-js\"><code>{\n  test: &#x2F;\\.(graphql|gql)$&#x2F;,\n  exclude: &#x2F;node_modules&#x2F;,\n  use: {\n    loader: &#x27;gq-loader&#x27;\n    options: {\n      url: &#x27;Graphql Server URL&#x27;,\n      &#x2F;&#x2F;指定自动请求模块路径\n      request: require.resolve(&#x27;your_request_module_path&#x27;);\n    }\n  }\n}\n</code></pre><p>在 <code>your_request_module_path</code> 填写自定义请求模块路径，<code>gq-loader</code> 将自动加载并使用对应请求模块，模块只需要改出一个「请求函数即可」，看如下自定义示例</p>\n<pre class=\"prettyprint language-js\"><code>const $ = require(&#x27;jquery&#x27;);\n\n&#x2F;&#x2F;url 是要请求的 GraphQL 服务地址\n&#x2F;&#x2F;data 是待发送的数据\n&#x2F;&#x2F;options 是自定义选项\nmodule.exports = function(url, data, options){\n  &#x2F;&#x2F;如果有需要还可以处理 options\n  return $.post(url, data);\n};\n</code></pre><p>其中，<code>options</code> 是导入 <code>.gql</code> 文件后「函数的第二个参数」，比如，可以这样传递 <code>options</code> 参数</p>\n<pre class=\"prettyprint language-js\"><code>import getUser from &#x27;.&#x2F;getUser.gql&#x27;;\n\nasync function query() {\n  const options = {...};\n  const user = await getUser({ name: &#x27;bob&#x27; }, options);\n  console.log(&#x27;user&#x27;, user);\n}\n</code></pre><h2>完整选项</h2>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>URL</td>\n<td>指定 graphql 服务 URL</td>\n<td>/graphql</td>\n</tr>\n<tr>\n<td>request</td>\n<td>自定义请求函数</td>\n<td>使用内建模块</td>\n</tr>\n<tr>\n<td>extensions</td>\n<td>默认扩展名，在导入时省略扩展名时将按配置依次查找</td>\n<td>.gql/.graphql</td>\n</tr>\n<tr>\n<td>string</td>\n<td>指定导入模式，当为 true 时导入为字符串，而不是可执行的函数</td>\n<td>false</td>\n</tr>\n</tbody>\n</table>\n<p>注意，<code>gq-loader</code> 的 <code>extensions</code> 无论配置何值，在 <code>js</code> 中 <code>import</code> 时都不能省略扩展名，此选项仅作用于 <code>.gql</code> 文件 <code>import</code> 其它 <code>.gql</code> 文件</p>\n</div>",
            "title": "前端调用 GraphQL API，从未如此方便！",
            "last_reply_at": "2018-01-29T11:26:44.291Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 308,
            "create_at": "2018-01-28T18:58:30.526Z",
            "author": {
                "loginname": "houfeng",
                "avatar_url": "//gravatar.com/avatar/4ccd30a6ccc36203b826a50047183ea6?size=48"
            }
        }, {
            "id": "5a6b3e189d371d4a059eeeed",
            "author_id": "5a5c0a17a3692d014f4f1477",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>浏览器 录音得到的blob 数据传到 后台，express框架用 multer接收，保存后，，播放没声音。。。</p>\n<p>怎么回事呢。。。。</p>\n<p>求大佬 赐教！！！</p>\n</div>",
            "title": "浏览器 录音得到的blob 数据传到 后台，express框架用 multer接收，保存后，，播放没声音。。。",
            "last_reply_at": "2018-01-29T11:25:43.853Z",
            "good": false,
            "top": false,
            "reply_count": 8,
            "visit_count": 316,
            "create_at": "2018-01-26T14:41:28.556Z",
            "author": {
                "loginname": "1160007652",
                "avatar_url": "https://avatars3.githubusercontent.com/u/26641790?v=4&s=120"
            }
        }, {
            "id": "5a6eff149d371d4a059eef86",
            "author_id": "576a5d4063075514079b77e7",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>翻译一篇国外哥们做的JavaScript 现状调查</p>\n<p>欢迎阅读 <a href=\"https://www.liayal.com/article/5a6ece2aeba8a1470c87f931\">2017年JavaScript 现状调查报告总结</a></p>\n</div>",
            "title": "2017年JavaScript 现状调查报告总结",
            "last_reply_at": "2018-01-29T11:01:40.541Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 46,
            "create_at": "2018-01-29T11:01:40.541Z",
            "author": {
                "loginname": "MaelWeb",
                "avatar_url": "https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"
            }
        }, {
            "id": "5a6ec0edafa0a121784a90db",
            "author_id": "5a6ebfaa9288dc8153288322",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><pre class=\"prettyprint\"><code>var timer = setInterval(function () {\n\tconsole.log(new Date, 1)\n}, 1000)\n\nvar fn = function () {\n\tconsole.log(new Date, 2)\n}\n\nvar timer2 = setInterval(fn, 1000)\ntimer2.unref()\n</code></pre><p>在这里一直会间断输出1， 2，  为什么timer2 的回调没有被取消</p>\n<ul>\n<li>使timer2正常unref\n1.但是将timer 这段代码去除就可以正常的取消timer2 的回调了，\n2、timer 也加上 unref</li>\n</ul>\n<p><strong><em>难道是永远只能有一个setInterval 在event loop中才能使用unref 生效吗</em></strong></p>\n</div>",
            "title": "time.unref 没有按预期取消对应的函数回调",
            "last_reply_at": "2018-01-29T10:22:03.457Z",
            "good": false,
            "top": false,
            "reply_count": 9,
            "visit_count": 147,
            "create_at": "2018-01-29T06:36:29.089Z",
            "author": {
                "loginname": "dmodaii",
                "avatar_url": "https://avatars1.githubusercontent.com/u/16190100?v=4&s=120"
            }
        }, {
            "id": "5a6dab899288dc81532882da",
            "author_id": "58de5214b3e60b982d089dc3",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>年纪大了快要撤回老家了, 西安基本没有node的机会, 已经学了一段时间java了, 你们有什么想说的😅\n<img src=\"//dn-cnode.qbox.me/FrLDAbf8qA3JKbhpABNC6ecHRh59\" alt=\"image.png\"></p>\n</div>",
            "title": "不得已要放下node, 转java了",
            "last_reply_at": "2018-01-29T10:17:19.429Z",
            "good": false,
            "top": false,
            "reply_count": 29,
            "visit_count": 1096,
            "create_at": "2018-01-28T10:52:57.720Z",
            "author": {
                "loginname": "XiaozhongLiu",
                "avatar_url": "https://avatars3.githubusercontent.com/u/17674404?v=4&s=120"
            }
        }, {
            "id": "5a68d49fafa0a121784a8f48",
            "author_id": "52c005d28a716e0b1578f9cc",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>好久不见，Yorkie 最近做了一个小东西，在此分享给大家！</p>\n<p>先放个链接：<a href=\"https://github.com/Rokid/shadow-node\">https://github.com/Rokid/shadow-node</a>\n从名字来看，他可不是一个 Node.js 的 C++ Addon，而是可以运行 Node.js 程序的另一个运行时（Runtime），相比 Node.js，具有更快的启动速度以及更小的内存占用、更加节省内存的模块加载方式！原来一个 Node.js 应用需要好几十M的运行时内存，现在可能只需要几兆就可以搞定了，并且拥有更快的启动速度。这也是因为 ShadowNode 不再使用 v8 作为 JavaScript 引擎，而是使用一款三星出品的 JerryScript 在做底层的解释执行！</p>\n<p>ShadowNode 目前支持的模块还比较有限，不过一些基础的如 HTTP/NET/DNS/Child Process 等都是支持的，并且除此之外，还默认支持 DBus 通讯方式，对于像 Linux 平台，简直是不要太方便，另外，对于硬件玩家，如果有兴趣移植到自己的开发板上的，也支持了诸如 I2C/ADC/GPIO 等这样的硬件接口，也就是说接入硬件仅仅写写脚本就能把你的硬件玩起来！另外，也可以把他移植到你家里的任意设备上，作为脚本语言使用，也是不错的选择！</p>\n<p>在此，我对 ShadowNode 寄予着非常大的希望，目前 Node.js 在嵌入式设备来说，无可避免都是内存占用的大户，之前 Tessel 曾经尝试把 JavaScript代码编译成 Lua 来达到降低内存的目的，也有一些不同的开发板使用像 JerryScript 这样低内存的引擎／虚拟机，然后仅仅支持了部分简单的模块以及 CommonJS，而我完全希望 ShadowNode 将更完全地支持 Node.js/Npm 模块，能够让 JavaScript 开发者能无缝在 Node.js 与 ShadowNode 中切换，尽量少地减少学习的成本！另外，ShadowNode 底层使用纯 C 编写，我们将大部分代码交给 C 来实现，JavaScript 仅仅作为胶水层语言！</p>\n<p>最后，搭车招个人！坐标杭州西溪，Rokid 公司，招募嵌入式、服务端以及社区增长黑客，共同点都是要热爱 JavaScript 以及 Node.js，简历的话直接去我 GitHub 邮件我就好了～</p>\n</div>",
            "title": "ShadowNode: 以更轻量级的方式使用 Node.js",
            "last_reply_at": "2018-01-29T09:56:41.571Z",
            "good": false,
            "top": false,
            "reply_count": 24,
            "visit_count": 801,
            "create_at": "2018-01-24T18:46:55.269Z",
            "author": {
                "loginname": "yorkie",
                "avatar_url": "https://avatars3.githubusercontent.com/u/1935767?v=4&s=120"
            }
        }, {
            "id": "5a6c66449288dc81532882ba",
            "author_id": "59588bdf545d7a7b5b0b389f",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>为自己这套http://vadmin.lanyueos.com模板写个vuex的例子，然后就拿cnode接口写了cnode首页。</p>\n<p><a href=\"http://vadmin.lanyueos.com/cnode\">传送门</a>\n<img src=\"//dn-cnode.qbox.me/FvCPxUE-VLPpMKLIac5hx_u0R9p-\" alt=\"image.png\"></p>\n<p><a href=\"https://github.com/mengdu/vue-element-admin-tpl\">vue-element-admin-tpl</a> 这个模板我是我工作和平时开发的积累，可以快速搭建后台管理平台系统的模板。\n我会不定期更新这个模板，欢迎star。</p>\n</div>",
            "title": "用vue写了一cnode首页，不一样的风格哦",
            "last_reply_at": "2018-01-29T09:54:01.118Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 421,
            "create_at": "2018-01-27T11:45:08.073Z",
            "author": {
                "loginname": "mengdu",
                "avatar_url": "https://avatars0.githubusercontent.com/u/11366654?v=4&s=120"
            }
        }, {
            "id": "5a6eeecb9d371d4a059eef7f",
            "author_id": "51ece401f4963ade0e95513a",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><blockquote>\n<p>这篇文章主要介绍nextTick和RunMicrotasks的主要流程和涉及到的相关源码，<em>对于timers相关api在event-loop中的表现不做解读</em></p>\n</blockquote>\n<h3>nextTick实现</h3>\n<p>目光直接转移到<a href=\"https://github.com/nodejs/node/blob/master/lib/internal/process/next_tick.js\">next_tick.js</a>，整体nextTick的代码其实很容易理解：</p>\n<pre class=\"prettyprint language-js\"><code> const [\n    tickInfo,\n    runMicrotasks\n  ] = process._setupNextTick(_tickCallback);\nfunction nextTick(callback) {\n   &#x2F;&#x2F; ...\n   nextTickQueue.push(new TickObject(callback, args, getDefaultTriggerAsyncId()));\n  }\nfunction _tickCallback() {\n    let tock;\n    do {\n      while (tock = nextTickQueue.shift()) {\n      &#x2F;&#x2F; ...\n      const callback = tock.callback;\n        if (tock.args === undefined)\n          callback();\n      runMicrotasks();\n    } while (nextTickQueue.head !== null || emitPromiseRejectionWarnings());\n    tickInfo[kHasPromiseRejections] = 0;\n  }\n</code></pre><p>通过这两个函数，就能看出来整个nextTick是如何工作的。</p>\n<ul>\n<li>nextTickQueue为记录nextTick的数组，有新的nextTick注册进来就会被推入数组</li>\n<li>_tickCallback则会不断的推出数组中的元素然后运行</li>\n</ul>\n<p>大家注意一下<code>process._setupNextTick(_tickCallback)</code>，最终这个_tickCallback并没有在js中执行，而是传递给了c++：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; node.cc\nvoid SetupNextTick(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n  Environment* env = Environment::GetCurrent(args);\n  CHECK(args[0]-&gt;IsFunction());\n  env-&gt;set_tick_callback_function(args[0].As&lt;Function&gt;());\n  &#x2F;&#x2F; ...\n</code></pre><p>在这里可以看出来，最终_tickCallback丢给了<code>tick_callback_function</code>，然后在<code>LoadEnvironment</code>中通过<code>_setupNextTick</code>触发运行（<code>LoadEnvironment</code>之前详细介绍过，在这里不做过多介绍）,在这里简单的追踪了一下_tickCallback来证实一下最终_tickCallback传递给了<code>tick_callback_function</code>：</p>\n<pre class=\"prettyprint language-js\"><code>process.nextTick(()=&gt;console.log(2))\n</code></pre><p><img src=\"https://github.com/xtx1130/blog/raw/master/images/issue16/issue16-1.png\" alt=\"issue16-1\"></p>\n<p>tips: 蓝色底色代码为断点所在位置，下方为此时刻的内存地址，上面这张图可以看出来在没有跑<code>LoadEnvironment</code>的时候，<code>tick_callback_function</code>为NULL</p>\n<p><img src=\"https://github.com/xtx1130/blog/raw/master/images/issue16/issue16-2.png\" alt=\"issue16-2\">\n如果对<code>LoadEnvironment</code>比较了解的读者，应该是明白其中的原理的，如果不明白原理可以简单看一下<code>tick_callback_function</code>这里的内存变化。这里我们假设读者了解node启动的所有机制，那么就会发现一件事情：<strong>在<code>process.nextTick</code>运行的时候，<code>uv_run</code>尚未启动</strong>。<br>\n那么，我们可以根据这个显现得出一个比较<em>浅显</em>的结论：<strong><code>process.nextTick</code>会阻塞libuv的事件循环</strong>。(这是在node初始化<em>bootatrap</em>阶段的情况。即使在evnt_loop中,表现也是一样的。为何用这个阶段来叙述，是因为这个阶段最容易追踪和解读)</p>\n<h3>process.nextTick和RunMicrotasks</h3>\n<p>通过前一章节的叙述和上一篇文章对setTimeout流程的分析，我们可以发现：<strong><code>process.nextTick</code>不是基于libuv事件机制的，而timers一系列的api全部是基于libuv开放出来的api实现的</strong>。那么这个nextTick到底是如何实现的呢？<br>\n接下来就要从nextTick的源码聊起了：</p>\n<pre class=\"prettyprint language-js\"><code>function _tickCallback() {\n    let tock;\n    do {\n      while (tock = nextTickQueue.shift()) {\n      &#x2F;&#x2F; ...\n      const callback = tock.callback;\n        if (tock.args === undefined)\n          callback();\n     &#x2F;&#x2F; ...\n     }\n      runMicrotasks();\n    } \n  &#x2F;&#x2F; ...\n  }\n</code></pre><p>在执行完nextTick之后（<code>callback()</code>）还继续执行了<code>runMicrotasks</code>，我相信如果了解过Microtasks的读者肯定知道这到底是做什么的，接下来我们深扒一下这个<code>runMicrotasks</code>：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F; src&#x2F;node.cc\nv8::Local&lt;v8::Function&gt; run_microtasks_fn =\n      env-&gt;NewFunctionTemplate(RunMicrotasks)-&gt;GetFunction(env-&gt;context())\n          .ToLocalChecked();&#x2F;&#x2F;v8 吐出来的方法 RunMicrotasks\nrun_microtasks_fn-&gt;SetName(\n      FIXED_ONE_BYTE_STRING(env-&gt;isolate(), &quot;runMicrotasks&quot;));\n\n&#x2F;&#x2F; deps&#x2F;v8&#x2F;src&#x2F;isolate.cc\nvoid Isolate::RunMicrotasks() {&#x2F;&#x2F; v8中RunMicrotasks实现\n  &#x2F;&#x2F; Increase call depth to prevent recursive callbacks.\n  v8::Isolate::SuppressMicrotaskExecutionScope suppress(\n      reinterpret_cast&lt;v8::Isolate*&gt;(this));\n  is_running_microtasks_ = true;\n  RunMicrotasksInternal();\n  is_running_microtasks_ = false;\n  FireMicrotasksCompletedCallback();\n}\nvoid Isolate::RunMicrotasksInternal() {\n  if (!pending_microtask_count()) return;\n  TRACE_EVENT0(&quot;v8.execute&quot;, &quot;RunMicrotasks&quot;);\n  TRACE_EVENT_CALL_STATS_SCOPED(this, &quot;v8&quot;, &quot;V8.RunMicrotasks&quot;);\n  while (pending_microtask_count() &gt; 0) {\n    HandleScope scope(this);\n    int num_tasks = pending_microtask_count();\n    Handle&lt;FixedArray&gt; queue(heap()-&gt;microtask_queue(), this);\n    DCHECK(num_tasks &lt;= queue-&gt;length());\n    set_pending_microtask_count(0);\n    heap()-&gt;set_microtask_queue(heap()-&gt;empty_fixed_array());\n  &#x2F;&#x2F; ...\n</code></pre><p>通过上面的代码，可以比较清晰地看到整个<code>RunMicrotasks</code>的全过程，主要就是通过microtask_queue来实现的Microtask。\n了解了整个流程，可以很容易得出一个结论：<strong>nextTick会在v8执行Microtasks之前对在js中注册的nextTickQueue逐个执行，即阻塞了Microtasks执行。</strong></p>\n<h3>bootstrap阶段和event-loop时候的异同</h3>\n<p>通过上面的分析，下面这段代码在bootstrap阶段，应该很容易理解：</p>\n<pre class=\"prettyprint language-js\"><code>setTimeout(()=&gt;console.log(&#x27;timers API&#x27;),0)&#x2F;&#x2F;uv_run开始运行后才执行timers相关api，最后执行\nconsole.log(&#x27;bootstrap&#x27;)&#x2F;&#x2F;在node LoadEnvironment(bootstrap)阶段执行，最先执行\nnew Promise((resolve,reject)=&gt; resolve(&#x27;microtask run&#x27;)).then(arg =&gt; console.log(arg))&#x2F;&#x2F;注册到microtask_queue中\nprocess.nextTick(()=&gt;console.log(&#x27;run next tick&#x27;))&#x2F;&#x2F; 会在microtask之前运行\n</code></pre><p>结果如图：\n<img src=\"https://github.com/xtx1130/blog/raw/master/images/issue16/issue16-3.png\" alt=\"issue16-3\">\n相关解释已经写到了上面的注释中。  （当然这里用console来作为同步代码不是很严谨，不过比较直观）</p>\n<p>那么在event-loop中是如何表现的呢？在上文中也提到过一句：</p>\n<blockquote>\n<p>这是在node初始化，即<em>bootstrap</em>的情况下，即使在evnt_loop中,表现也是一样的</p>\n</blockquote>\n<p>event-loop中的区别是：<strong>本应该在node LoadEnvironment(bootstrap)阶段执行的代码的运行转移到了<code>InternalMakeCallback</code>中</strong>。<br>\n下面是<code>InternalMakeCallback</code>的代码：</p>\n<pre class=\"prettyprint language-c\"><code>&#x2F;&#x2F; .&#x2F;src&#x2F;node.cc\nMaybeLocal&lt;Value&gt; InternalMakeCallback(Environment* env,\n                                       Local&lt;Object&gt; recv,\n                                       const Local&lt;Function&gt; callback,\n                                       int argc,\n                                       Local&lt;Value&gt; argv[],\n                                       async_context asyncContext) {\n  CHECK(!recv.IsEmpty());\n  InternalCallbackScope scope(env, recv, asyncContext);\n  if (scope.Failed()) {\n    return Undefined(env-&gt;isolate());\n  }\n\n  MaybeLocal&lt;Value&gt; ret;\n\n  {\n    ret = callback-&gt;Call(env-&gt;context(), recv, argc, argv);\n    &#x2F;&#x2F; ...\n  }\n &#x2F;&#x2F; ...\n  return ret;\n}\n</code></pre><p>通过<code>ret = callback-&gt;Call(env-&gt;context(), recv, argc, argv);</code>实现了event-loop中主体代码的运行，之后在InternalMakeCallback结束之后，实现对nextTick和microtask的调用，代码如下：</p>\n<pre class=\"prettyprint language-c\"><code>&#x2F;&#x2F; .&#x2F;src&#x2F;node.cc\nvoid InternalCallbackScope::Close() {\n  &#x2F;&#x2F; ...\n  Environment::TickInfo* tick_info = env_-&gt;tick_info();\n\n  if (!tick_info-&gt;has_scheduled()) {\n    env_-&gt;isolate()-&gt;RunMicrotasks();\n  }\n  &#x2F;&#x2F; ...\n  if (!tick_info-&gt;has_scheduled() &amp;&amp; !tick_info-&gt;has_promise_rejections()) {\n    return;\n  }\n  &#x2F;&#x2F; ...\n  Local&lt;Object&gt; process = env_-&gt;process_object();\n\n  if (env_-&gt;tick_callback_function()-&gt;Call(process, 0, nullptr).IsEmpty()) {\n    failed_ = true;\n  }\n}\n</code></pre><p>其中，有两个需要注意的地方，一个是：</p>\n<pre class=\"prettyprint language-c++\"><code> if (!tick_info-&gt;has_scheduled()) {\n    env_-&gt;isolate()-&gt;RunMicrotasks();\n  }\n &#x2F;&#x2F; ...\n  if (!tick_info-&gt;has_scheduled() &amp;&amp; !tick_info-&gt;has_promise_rejections()) {\n    return;\n  }\n</code></pre><p>这两处代码专门针对无process.nextTick行为的event-loop进行了处理，直接从node中调用v8的RunMicrotasks，加快整体处理速度。<br>\n另外一个地方是：</p>\n<pre class=\"prettyprint language-c++\"><code>if (env_-&gt;tick_callback_function()-&gt;Call(process, 0, nullptr).IsEmpty()) {\n    failed_ = true;\n  }\n</code></pre><p>通过对tick_callback_function的调用，实现触发之前讲过的<code>_tickCallback</code>,不知道大家还记得这句话么：</p>\n<blockquote>\n<p>在这里简单的追踪了一下_tickCallback来证实一下最终_tickCallback传递给了<code>tick_callback_function</code></p>\n</blockquote>\n<p>这样，整体形成了一个闭环，无论是bootstrap阶段还是在event-loop阶段，总是能保证两点：</p>\n<ul>\n<li>nextTick永远在主函数（包括同步代码和console）运行完之后运行</li>\n<li>nextTick永远优先于microtask运行</li>\n</ul>\n<p>by 小菜\n原文地址：<a href=\"https://github.com/xtx1130/blog/issues/16\">https://github.com/xtx1130/blog/issues/16</a>，欢迎star和watch，如果文中有讲解错误的地方欢迎指正</p>\n</div>",
            "title": "node源码粗读（7）：nextTick和microtasks从bootstrap到event-loop全阶段解读",
            "last_reply_at": "2018-01-29T09:52:11.844Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 48,
            "create_at": "2018-01-29T09:52:11.844Z",
            "author": {
                "loginname": "xtx1130",
                "avatar_url": "https://avatars2.githubusercontent.com/u/5475069?v=4&s=120"
            }
        }, {
            "id": "5a6edba9ce45d440451464bc",
            "author_id": "578f933cb78759e813a57ae6",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>现在找人都比较看经验呢，之前一直是干的产品，越做越不顺心，思考一番决定转行。\n也用Node写过小玩意，但是吧肯定上不了台面。也不能说自己闷头学个一年半年再来找。\n想问问有没有前辈也是转行的成功，讨教些经验，小弟在此谢过啦~</p>\n</div>",
            "title": "3年产品转node，怎么样比较顺利的拿到面试机会",
            "last_reply_at": "2018-01-29T09:31:30.921Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 123,
            "create_at": "2018-01-29T08:30:33.497Z",
            "author": {
                "loginname": "webzmy",
                "avatar_url": "https://avatars.githubusercontent.com/u/20560499?v=3&s=120"
            }
        }, {
            "id": "5a6e9119ce45d4404514648f",
            "author_id": "591e3dd29e32cc84569a7109",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>原来的是定义了这样一个方法：</p>\n<pre class=\"prettyprint\"><code>let reactionScheduler: (fn: () =&gt; void) =&gt; void = f =&gt; f()\n</code></pre><p>看了好久没看懂这个方法干哈用的，于是就拿去跑一下编译，结果出来的结果更是让我不能理解。 \t\n结果如下：</p>\n<pre class=\"prettyprint\"><code>var reactionScheduler = function (f) { return f(); };\n</code></pre><p>有没有大神给剖析一把上面的方法。 \t\n再一个问题是，定义这个方法的意义在哪里？</p>\n</div>",
            "title": "看到一个typescript方法，不能理解，看了编译结果，更不能理解了",
            "last_reply_at": "2018-01-29T08:26:38.161Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 223,
            "create_at": "2018-01-29T03:12:25.449Z",
            "author": {
                "loginname": "wangchaoduo",
                "avatar_url": "https://avatars0.githubusercontent.com/u/16484068?v=4&s=120"
            }
        }, {
            "id": "5a6addc99d371d4a059eeec2",
            "author_id": "57ff53e527a1d99178a98e23",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>最经在搭一个koa2+react的ssr架构，遇到个问题，path=&quot;/“需要重定向到path=”/home&quot;\njsx里面用到&lt;Route path=&quot;/&quot; render={() =&gt; &lt;Redirect to=&quot;/home&quot; /&gt;} /&gt;\nssr用到的代码如下\nssr-entry.js\n<img src=\"//dn-cnode.qbox.me/FhzeIptlddUzZZVha_Ie4bXA1ok-\" alt=\"1516951924(1).jpg\">\nserver.js\n<img src=\"//dn-cnode.qbox.me/FmvxwqNHt_BbH9A3UILIXml6EuTS\" alt=\"1516952176(1).jpg\"></p>\n<p>可以看到我现在是那ctx.url判断写死重定向到/home的\n但实际上按照react-router V4的官方文档，</p>\n<p>我应该在<code>const app = await serverBundle(store, routerContext, ctx.url);</code>之后去判断routerContext.url是否存在。\n但是当我按照官方文档的写法，访问path=&quot;/&quot;的路径，routerContext依然是{}。\n<img src=\"//dn-cnode.qbox.me/Fr-DQVR7V6s8wYBRv8ZOJH7_ZM2h\" alt=\"1516952527(1).jpg\">\n<img src=\"//dn-cnode.qbox.me/FuP5nTbchidezH8gzo7W31fCABGB\" alt=\"1516952891(1).jpg\">\n可以看到访问/的时候，打印的routerContext依然为{}</p>\n<p>希望我表述清楚了，求大牛给支个招，是我少做了哪一步吗？之前用express做过是没问题的。</p>\n</div>",
            "title": "koa2+react搭建ssr时，服务端做重定向时不能正确拿到StaticRouter处理过后的context",
            "last_reply_at": "2018-01-29T07:35:38.996Z",
            "good": false,
            "top": false,
            "reply_count": 6,
            "visit_count": 373,
            "create_at": "2018-01-26T07:50:33.444Z",
            "author": {
                "loginname": "chtic123",
                "avatar_url": "https://avatars1.githubusercontent.com/u/15922086?v=4&s=120"
            }
        }, {
            "id": "5a6748a9ce45d440451462ad",
            "author_id": "57d216e13d3520a5387c2b53",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>RT</p>\n</div>",
            "title": "大家好，请问在mongodb的数据库优化上面，有哪方面的建议吗？",
            "last_reply_at": "2018-01-29T06:48:06.655Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 599,
            "create_at": "2018-01-23T14:37:29.556Z",
            "author": {
                "loginname": "a69694510",
                "avatar_url": "https://avatars1.githubusercontent.com/u/20507053?v=4&s=120"
            }
        }, {
            "id": "5933d125739a92064a1bd4b6",
            "author_id": "590d7e623504ce1c2ac45912",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><blockquote>\n<p><a href=\"http://cnodejs.org/topic/59294bff9e32cc84569a746a\">【Node.js 微信公众号实战】1.Node.js 接入微信公众平台开发</a>\n<a href=\"http://cnodejs.org/topic/5933d125739a92064a1bd4b6\">【Node.js 微信公众号实战】2.Node.js access_token的获取、存储及更新</a>\n<a href=\"https://cnodejs.org/topic/593668946b7ebe7e2979d8c6\">【Node.js 微信公众号实战】3.Node.js 自定义微信菜单</a>\n<a href=\"https://cnodejs.org/topic/5939fa64d3575f1303de3aab\">【Node.js 微信公众号实战】4.Node.js 微信消息管理</a></p>\n</blockquote>\n<h2>一、写在前面的话</h2>\n<p>  上一篇文章中，我们使用 Node.js 成功的实现了接入微信公众平台功能。在这篇文章中，我们将实现微信公众平台一个非常重要的参数 access_token ,它是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用 access_token。</p>\n<p>  在开始之前，让我们先按捺住自己激动的心情、调整好呼吸，因为我们要将上一篇文章的代码重新整理一下。一个好的项目结构，更能有助于我们理清业务逻辑以及将来维护代码的便捷。OK!\n<img src=\"http://img.blog.csdn.net/20170528115031656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"Are you ready?\"></p>\n<h2>二、整理项目结构</h2>\n<p>1.打开我们的项目，并在项目中添加文件夹，命名为 wechat ，如图:\n<img src=\"http://img.blog.csdn.net/20170604122937701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<p>2.在 wechat 文件夹中添加文件并命名为 wechat.js。wechat.js 主要用于封装开发微信公众平台的所有方法。首先我们构建这个模块的结构，代码如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27; &#x2F;&#x2F;设置为严格模式\n\n&#x2F;&#x2F;构建 WeChat 对象 即 js中 函数就是对象\nvar WeChat = function(config){\n    &#x2F;&#x2F;设置 WeChat 对象属性 config\n    this.config = config;\n    \n    &#x2F;&#x2F;设置 WeChat 对象属性 token\n    this.token = config.token;\n}\n\n&#x2F;&#x2F;暴露可供外部访问的接口\nmodule.exports = WeChat;\n</code></pre><p> 严格模式：是在 ECMAScript 5 中引入的概念。严格模式是为 Javascript 定义了一种解析与执行模型。</p>\n<p> module.exports ：暴露接口用于外部操作。实际上我们定义模块后，使用 node.js 的 require 引用时，node.js 会自动在我们定义的模块外层加入以下代码</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * exports  module.exports 的一个简短的引用\n * require  用于引入模块\n * module   当前模块的引用\n * __filename  当前模块的文件名\n * __dirname   当前模块的目录名\n *&#x2F;\n(function (exports, require, module, __filename, __dirname) {\n    &#x2F;&#x2F;自定义模块的代码块\n})();\n</code></pre><p>相信对于有过 javascript 开发经验的同学，上面的代码并不陌生。我们可以将它理解为一个闭包，是一个匿名方法的调用，避免污染全局变量。</p>\n<blockquote>\n<p>小知识：</p>\n<p>  在上面的代码中，除了我们所使用的 module.exports 对象，还有另一个用于暴露接口的 变量 exports (官方文档将 module.exports 称为对象，exports 称为 属性，我在这里也就这样称呼了)，那么 module.exports 与 exports 有什么区别呢？</p>\n<p>  module.exports 对象是由模块系统创建的，exports 变量是在模块的文件级别作用域内有效的，它在模块被执行前被赋于 module.exports 的值。——<a href=\"https://nodejs.org/dist/latest-v6.x/docs/api/modules.html#modules_module_exports\">来自Node.js官方文档</a></p>\n<p>  也就是说 exports 是 module.exports 的引用，而 module.exports 才是真正用于暴露接口的对象。 exports 赋值的所有属性与方法都赋值给了 module.exports 对象。</p>\n<p>  如果 module.exports 与 exports 将值赋值给了相同的属性，则按照赋值的先后顺序，取最后一个赋值；如果我们给 module.exports 赋值的是一个对象，则会覆盖 exports 的所有方法与属性。</p>\n<p>  因此我们在暴露接口的使用上，如果只是单一属性或方法的话，建议使用exports.属性/方法，要是导出多个属性或方法或使用对象构造方法，建议使用 module.exports。</p>\n<p>  具体详解可以点击查看该文章 -&gt; <a href=\"https://www.ycjcl.cc/2017/02/10/module-exportshe-exportsde-qu-bie/?utm_source=tuicool&amp;utm_medium=referral\">Module.exports和exports的区别</a></p>\n</blockquote>\n<p>3.为 WeChat 对象添加一个方法 auth，并将 app.js 中的验证方法粘贴进去</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27; &#x2F;&#x2F;设置为严格模式\n\nconst crypto = require(&#x27;crypto&#x27;); &#x2F;&#x2F;引入加密模块\n\n&#x2F;&#x2F;构建 WeChat 对象 即 js中 函数就是对象\nvar WeChat = function(config){\n    &#x2F;&#x2F;设置 WeChat 对象属性 config\n    this.config = config;\n\n    &#x2F;&#x2F;设置 WeChat 对象属性 token\n    this.token = config.token;\n}\n\n&#x2F;**\n * 微信接入验证\n *&#x2F;\nWeChat.prototype.auth = function(req,res){\n     &#x2F;&#x2F;1.获取微信服务器Get请求的参数 signature、timestamp、nonce、echostr\n        var signature = req.query.signature,&#x2F;&#x2F;微信加密签名\n            timestamp = req.query.timestamp,&#x2F;&#x2F;时间戳\n                nonce = req.query.nonce,&#x2F;&#x2F;随机数\n            echostr = req.query.echostr;&#x2F;&#x2F;随机字符串\n\n        &#x2F;&#x2F;2.将token、timestamp、nonce三个参数进行字典序排序\n        var array = [this.token,timestamp,nonce];\n        array.sort();\n\n        &#x2F;&#x2F;3.将三个参数字符串拼接成一个字符串进行sha1加密\n        var tempStr = array.join(&#x27;&#x27;);\n        const hashCode = crypto.createHash(&#x27;sha1&#x27;); &#x2F;&#x2F;创建加密类型 \n        var resultCode = hashCode.update(tempStr,&#x27;utf8&#x27;).digest(&#x27;hex&#x27;); &#x2F;&#x2F;对传入的字符串进行加密\n\n        &#x2F;&#x2F;4.开发者获得加密后的字符串可与signature对比，标识该请求来源于微信\n        if(resultCode === signature){\n            res.send(echostr);\n        }else{\n            res.send(&#x27;mismatch&#x27;);\n        }\n}\n\n&#x2F;&#x2F;暴露可供外部访问的接口\nmodule.exports = WeChat;\n</code></pre><p>4.整理 app.js 文件的中的代码，如下：</p>\n<pre class=\"prettyprint language-javascript\"><code>const express = require(&#x27;express&#x27;), &#x2F;&#x2F;express 框架 \n      wechat  = require(&#x27;.&#x2F;wechat&#x2F;wechat&#x27;), \n       config = require(&#x27;.&#x2F;config&#x27;);&#x2F;&#x2F;引入配置文件\n\nvar app = express();&#x2F;&#x2F;实例express框架\n\nvar wechatApp = new wechat(config); &#x2F;&#x2F;实例wechat 模块\n\n&#x2F;&#x2F;用于处理所有进入 3000 端口 get 的连接请求\napp.get(&#x27;&#x2F;&#x27;,function(req,res){\n    wechatApp.auth(req,res);\n});\n\n&#x2F;&#x2F;监听3000端口\napp.listen(3000);\n</code></pre><p>嗯！这样代码看着是不是舒服多了呢。<img src=\"http://img.blog.csdn.net/20170528144657102?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"机智如我\"></p>\n<p>剩下的就是去微信公众平台接入验证了，在<a href=\"http://cnodejs.org/topic/59294bff9e32cc84569a746a\">上一篇文章</a>中有详细的教程，这里我就不再演示了</p>\n<p><img src=\"http://img.blog.csdn.net/20170528145316329?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"就是这么懒\"></p>\n<h2>三、access_token的获取、存储及更新</h2>\n<p>1.微信文档步骤</p>\n<p>  在开始码代码之前，我们依然是先理清实现的思路，在开始编写实现代码。打开 <a href=\"https://mp.weixin.qq.com/wiki\">微信帮助文档</a> ，点击左侧菜单中的开始开发，点击其子菜单获取access_token，如图：\n<img src=\"http://img.blog.csdn.net/20170528151333883?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"获取access_token\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170529203221439?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"获取access_token 帮助文档\"></p>\n<p>通过上面的 API 的描述，我们总结出以下步骤：</p>\n<ol>\n<li>实现 https  Get 请求</li>\n<li>获取 access_token 并存储  如果 当前 access_token 过期则更新</li>\n</ol>\n<p>2.access_token的获取、存储及更新 代码实现</p>\n<p>  整理好思路后我们就按照上一节的步骤去实现。通过帮助文档我们将用于请求微信API 的请求地址与参数，存放到 config.json 文件。</p>\n<p>  其中 appid 与 secret 两个参数 位于  <a href=\"https://mp.weixin.qq.com/\">微信公众平台</a> 左侧菜单的基本配置中，如图：\n<img src=\"http://img.blog.csdn.net/20170527134810969?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"微信公众平台 - 基本配置\"></p>\n<p><img src=\"http://img.blog.csdn.net/20170601095037229?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"APPID 与 AppSecret\"></p>\n<p>开发者密码 点击重置，用手机微信扫面二维码后便可得到。config.json 代码如下</p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;token&quot;:&quot;wechat&quot;,\n    &quot;appID&quot;:&quot;wx154f********764da&quot;,\n    &quot;appScrect&quot;:&quot;59de4266*******8dbe9de4b798cd372&quot;,\n    &quot;apiDomain&quot;:&quot;https:&#x2F;&#x2F;api.weixin.qq.com&#x2F;&quot;,\n    &quot;apiURL&quot;:{\n        &quot;accessTokenApi&quot;:&quot;%scgi-bin&#x2F;token?grant_type=client_credential&amp;appid=%s&amp;secret=%s&quot;\n    }\n}\n</code></pre><p>由于微信 API 请求连接的域名是公用的，我们将它提出来，在请求地址中使用 %s(字符串) 占位符占位。</p>\n<p>  微信所有请求连接都是 https 协议，很幸运的是 Node.js 系统包中为我们提供了 https 的包，由于后面的请求会多次用到 https ，因此我们将它封装为一个公用的方法，以便以后的使用，再次打开  wechat.js 在构造方法中，引入 https 模块，并在构造函数内部添加 requestGet 方法</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;用于处理 https Get请求方法\n    this.requestGet = function(url){\n        return new Promise(function(resolve,reject){\n            https.get(url,function(res){\n                var buffer = [],result = &quot;&quot;;\n                &#x2F;&#x2F;监听 data 事件\n                res.on(&#x27;data&#x27;,function(data){\n                    buffer.push(data);\n                });\n                &#x2F;&#x2F;监听 数据传输完成事件\n                res.on(&#x27;end&#x27;,function(){\n                    result = Buffer.concat(buffer,buffer.length).toString(&#x27;utf-8&#x27;);\n                    &#x2F;&#x2F;将最后结果返回\n                    resolve(result);\n                });\n            }).on(&#x27;error&#x27;,function(err){\n                reject(err);\n            });\n        });\n    }\n</code></pre><blockquote>\n<p>提示：</p>\n<p>    npm 提供了很多用于请求的工具包，比如 request ( 安装命令 npm install request ) 等。这里我只是用系统包去做请求处理。</p>\n</blockquote>\n<p>  由于 https 是异步请求的，我在这里面使用了 ES6 的 <a href=\"http://es6.ruanyifeng.com/#docs/promise\">Promise 对象</a> 。</p>\n<p>  完成了 requestGet方法后，我们的第1步骤也就完成了。下面开始第2步，获取 access_token 并存储  如果 当前 access_token 过期则更新。</p>\n<p>  在这之前我是想将 access_token 的存储位置依然放在 config.json 文件中，由于 access_token 在更新后 需要将文件重写，可能容易造成 config.json 文件的格式的紊乱，因此在 wechat 中重新创建一个 accessToken.json 文件用于存储 access_token\n<img src=\"http://img.blog.csdn.net/20170604130201533?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"这里写图片描述\"></p>\n<pre class=\"prettyprint language-javascript\"><code>{\n    &quot;access_token&quot;:&quot;&quot;,\n    &quot;expires_time&quot;:0\n}\n</code></pre><p>   其中 access_token 用于存储  我们 GET 请求后access_token 的值，expires_time 用于存储 access_token 的过期时间，保存为时间戳。</p>\n<p>  在 wechat.js 引入 fs 模块用于操作文件、util 工具模块用于处理占位符、  accessToken.json 文件</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x27;use strict&#x27; &#x2F;&#x2F;设置为严格模式\n\nconst crypto = require(&#x27;crypto&#x27;), &#x2F;&#x2F;引入加密模块\n       https = require(&#x27;https&#x27;), &#x2F;&#x2F;引入 htts 模块\n        util = require(&#x27;util&#x27;), &#x2F;&#x2F;引入 util 工具包\naccessTokenJson = require(&#x27;.&#x2F;access_token&#x27;); &#x2F;&#x2F;引入本地存储的 access_token\n\n&#x2F;&#x2F;构建 WeChat 对象 即 js中 函数就是对象\nvar WeChat = function(config){\n    &#x2F;&#x2F;设置 WeChat 对象属性 config\n    this.config = config;\n    &#x2F;&#x2F;设置 WeChat 对象属性 token\n    this.token = config.token;\n    &#x2F;&#x2F;设置 WeChat 对象属性 appID\n    this.appID = config.appID;\n    &#x2F;&#x2F;设置 WeChat 对象属性 appScrect\n    this.appScrect = config.appScrect;\n    &#x2F;&#x2F;设置 WeChat 对象属性 apiDomain\n    this.apiDomain = config.apiDomain;\n    &#x2F;&#x2F;设置 WeChat 对象属性 apiURL\n    this.apiDomain = config.apiURL;\n\n    &#x2F;&#x2F;用于处理 https Get请求方法\n    this.requestGet = function(url){\n        return new Promise(function(resolve,reject){\n            https.get(url,function(res){\n                var buffer = [],result = &quot;&quot;;\n                &#x2F;&#x2F;监听 data 事件\n                res.on(&#x27;data&#x27;,function(data){\n                    buffer.push(data);\n                });\n                &#x2F;&#x2F;监听 数据传输完成事件\n                res.on(&#x27;end&#x27;,function(){\n                    result = Buffer.concat(buffer,buffer.length).toString(&#x27;utf-8&#x27;);\n                    &#x2F;&#x2F;将最后结果返回\n                    resolve(result);\n                });\n            }).on(&#x27;error&#x27;,function(err){\n                reject(err);\n            });\n        });\n    }\n}\n</code></pre><p>  在 wechat.js  添加获取 access_token 的方法 getAccessToken</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;**\n * 获取微信 access_token\n *&#x2F;\nWeChat.prototype.getAccessToken = function(){\n    var that = this;\n    return new Promise(function(resolve,reject){\n        &#x2F;&#x2F;获取当前时间 \n        var currentTime = new Date().getTime();\n        &#x2F;&#x2F;格式化请求地址\n        var url = util.format(that.apiURL.accessTokenApi,that.apiDomain,that.appID,that.appScrect);\n        &#x2F;&#x2F;判断 本地存储的 access_token 是否有效\n        if(accessTokenJson.access_token === &quot;&quot; || accessTokenJson.expires_time &lt; currentTime){\n            that.requestGet(url).then(function(data){\n                var result = JSON.parse(data); \n                if(data.indexOf(&quot;errcode&quot;) &lt; 0){\n                    accessTokenJson.access_token = result.access_token;\n                    accessTokenJson.expires_time = new Date().getTime() + (parseInt(result.expires_in) - 200) * 1000;\n                    &#x2F;&#x2F;更新本地存储的\n                    fs.writeFile(&#x27;.&#x2F;wechat&#x2F;access_token.json&#x27;,JSON.stringify(accessTokenJson));\n                    &#x2F;&#x2F;将获取后的 access_token 返回\n                    resolve(accessTokenJson.access_token);\n                }else{\n                    &#x2F;&#x2F;将错误返回\n                    resolve(result);\n                } \n            });\n        }else{\n            &#x2F;&#x2F;将本地存储的 access_token 返回\n            resolve(accessTokenJson.access_token);  \n        }\n    });\n}\n</code></pre><p>  在 app.js  中添加新的监听链接用于测试 我们获取的token</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F;用于请求获取 access_token\napp.get(&#x27;&#x2F;getAccessToken&#x27;,function(req,res){\n    wechatApp.getAccessToken().then(function(data){\n        res.send(data);\n    });    \n});\n</code></pre><p><img src=\"http://img.blog.csdn.net/20170604170244323?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"获取access_token的效果图\"></p>\n<p>  这样我们就大功告成了！</p>\n<p><img src=\"http://img.blog.csdn.net/20170604171234743?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvaHZrQ29kZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast\" alt=\"年轻人恭喜你\"></p>\n<p>  文章源代码：<a href=\"https://github.com/SilenceHVK/wechatByNode\">https://github.com/SilenceHVK/wechatByNode</a> 。对文章有不正确之处，请给予纠正。github源代码请顺手给个 Star，最后感谢您的阅读。</p>\n</div>",
            "title": "【Node.js 微信公众号实战】2.Node.js access_token的获取、存储及更新",
            "last_reply_at": "2018-01-29T05:47:24.174Z",
            "good": true,
            "top": false,
            "reply_count": 17,
            "visit_count": 7782,
            "create_at": "2017-06-04T09:21:41.529Z",
            "author": {
                "loginname": "SilenceHVK",
                "avatar_url": "https://avatars3.githubusercontent.com/u/12862565?v=4&s=120"
            }
        }, {
            "id": "5a6d777f9d371d4a059eef29",
            "author_id": "56276af03f017c2b49b41575",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>最近在研究大麦的购票流程，中间有个 URL 的跳转实在百思不得其解。\n以这个 URL 为例：&lt;<a href=\"http://www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0\">www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0</a>&gt;\n在浏览器输入后页面会跳转到 <a href=\"https://trade.damai.cn/multi/confirm?***\">https://trade.damai.cn/multi/confirm?***</a> 这样一个页面。\n我直接用 charles 抓包，结果如下：\n<img src=\"//dn-cnode.qbox.me/FuhmJfc3VIN2SEmC-xBtrQPdN14M\" alt=\"1.png\">\n截图框内部分正是最后重定向到的链接。\n但是我用 Node 来模拟请求，想得到请求的页面，始终拿不到，我也尝试获取 302 跳转前的页面：</p>\n<pre class=\"prettyprint language-js\"><code>superagent\n    .get(url)\n    .set(&#x27;Cookie&#x27;, cookie)\n    .redirects(0)\n    .on(&#x27;error&#x27;, err =&gt; {\n      console.log(err.response.text)\n    })\n    .end(function (err, sres) { &#x2F;&#x2F; callback\n    })\n</code></pre><p>我省略了一些请求头，实际上我都带上了，结果如下：\n<img src=\"//dn-cnode.qbox.me/FluRCpPQw7DffageBmoY0iILXGid\" alt=\"2.png\">\n而且我也获取不到最后重定向页面的代码，一直获取的是商品详情页，也就是这个页面 <a href=\"https://piao.damai.cn/141343.html\">https://piao.damai.cn/141343.html</a> 的代码。\n我有两个问题：</p>\n<ol>\n<li>我怎么根据 &lt;<a href=\"http://www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0\">www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0</a>&gt; 获取最后跳转到的页面的 URL（假设有 cookie 等所有请求头信息）</li>\n<li>怎么根据 &lt;<a href=\"http://www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0\">www.damai.cn/GotoShopping.aspx?_action=Immediately&amp;proId=12123708&amp;optype=1&amp;companyId=1580&amp;num=1&amp;n=0</a>&gt; 获取最后跳转到的页面的 HTML 代码？我将所有头部信息全部填完后模拟请求，一直请求到的是商品详情页也就是这个页面 <a href=\"https://piao.damai.cn/141343.html\">https://piao.damai.cn/141343.html</a> 的代码，不知道哪个环节出了问题</li>\n</ol>\n<p>我用的 HTTP 库是 superagent，望赐教！</p>\n</div>",
            "title": "求分析一个神奇的 HTTP 跳转",
            "last_reply_at": "2018-01-29T05:06:50.792Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 343,
            "create_at": "2018-01-28T07:10:55.051Z",
            "author": {
                "loginname": "hanzichi",
                "avatar_url": "https://avatars3.githubusercontent.com/u/10890665?v=4&s=120"
            }
        }, {
            "id": "5a30c4929807389a1809f352",
            "author_id": "515005e9604b3d512109bb17",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><blockquote>\n<p><a href=\"https://zhuanlan.zhihu.com/p/31966196\">本文</a>首发于知乎专栏<a href=\"https://zhuanlan.zhihu.com/xtech\">蚂蚁金服体验科技</a>。</p>\n</blockquote>\n<p>首先声明，我在“Bug”字眼上加了引号，自然是为了说明它并非一个真 Bug。</p>\n<h2>问题抛出</h2>\n<p>昨天有个童鞋在看后台监控的时候，突然发现了一个错误：</p>\n<pre class=\"prettyprint\"><code>[error] 000001#0: ... upstream prematurely closed connection while reading response header from upstream.\n  client: 10.10.10.10\n  server: foo.com\n  request: &quot;GET &#x2F;foo&#x2F;bar?rmicmd,begin run clean docker images job HTTP&#x2F;1.1&quot;\n  upstream: &quot;http:&#x2F;&#x2F;...&quot;\n</code></pre><p>大概意思就是说：一台服务器通过 HTTP 协议去请求另一台服务器的时候，单方面被对方服务器断开了连接——并且并没有任何返回。</p>\n<h2>开始重现</h2>\n<h3>客户端 CURL 指令</h3>\n<p>其实这次请求的一些猫腻很容易就能发现——在 URL 中有空格。所以我们能简化出一条最简单的 CURL 指令：</p>\n<pre class=\"prettyprint language-sh\"><code>$ curl &quot;http:&#x2F;&#x2F;foo&#x2F;bar baz&quot; -v\n</code></pre><blockquote>\n<p>**注意：**不带任何转义。</p>\n</blockquote>\n<h3>最小 Node.js 源码</h3>\n<p>好的，那么接下去开始写相应的最简单的 Node.js HTTP 服务端源码。</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst http = require(&#x27;http&#x27;);\n\nconst server = http.createServer(function(req, resp) {\n    console.log(&#x27;🌚&#x27;);\n    resp.end(&#x27;hello world&#x27;);\n});\n\nserver.listen(5555);\n</code></pre><p>大功告成，启动这段 Node.js 代码，开始试试看上面的指令吧。</p>\n<p>如果你也正在跟着尝试这件事情的话，你就会发现 Node.js 的命令行没有输出任何信息，尤其是嘲讽的 <code>'🌚'</code>，而在 CURL 的结果中，你将会看见：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;d d&#x27; -v\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)\n&gt; GET &#x2F;d d HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n* Empty reply from server\n* Connection #0 to host 127.0.0.1 left intact\ncurl: (52) Empty reply from server\n</code></pre><p>瞧，<strong>Empty reply from server</strong>。</p>\n<h3>Nginx</h3>\n<p>发现了问题之后，就有另一个问题值得思考了：就 Node.js 会出现这种情况呢，还是其它一些 HTTP 服务器也会有这种情况呢。</p>\n<p>于是拿小白鼠 Nginx 做了个实验。我写了这么一个配置：</p>\n<pre class=\"prettyprint language-nginx\"><code>server {\n    listen 5555;\n\n    location &#x2F; {\n        return 200 $uri;\n    }\n}\n</code></pre><p>接着也执行一遍 CURL，得到了如下的结果：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;d d&#x27; -v\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)\n&gt; GET &#x2F;d d HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n&lt; HTTP&#x2F;1.1 200 OK\n&lt; Server: openresty&#x2F;1.11.2.1\n&lt; Date: Tue, 12 Dec 2017 09:07:56 GMT\n&lt; Content-Type: application&#x2F;octet-stream\n&lt; Content-Length: 4\n&lt; Connection: keep-alive\n&lt;\n* Connection #0 to host xcoder.in left intact\n&#x2F;d d\n</code></pre><p><img src=\"http://ww2.sinaimg.cn/bmiddle/a15b4afegy1fmf43teykfj20c80c8ta0\" alt=\"厉害了，我的 Nginx\"></p>\n<p>于是乎，理所当然，我<strong>暂时</strong>将这个事件定性为 Node.js 的一个 Bug。</p>\n<h2>Node.js 源码排查</h2>\n<p>认定了它是个 Bug 之后，我就开始了一贯的看源码环节——由于这个 Bug 的复现条件比较明显，我暂时将其定性为“Node.js HTTP 服务端模块在接到请求后解析 HTTP 数据包的时候解析 URI 时出了问题”。</p>\n<h3>http.js -&gt; _http_server.js -&gt; _http_common.js</h3>\n<blockquote>\n<p>源码以 <a href=\"https://github.com/nodejs/node/tree/v8.9.2\">Node.js 8.9.2</a> 为准。</p>\n</blockquote>\n<p>这里先预留一下我们能马上想到的 <strong>node_http_parser.cc</strong>，而先讲这几个文件，是有原因的——这涉及到最后的一个应对方式。</p>\n<p>首先看看 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/lib/http.js#L33-L35\"><strong>lib/http.js</strong></a> 的相应源码：</p>\n<pre class=\"prettyprint language-js\"><code>...\nconst server = require(&#x27;_http_server&#x27;);\n\nconst { Server } = server;\n\nfunction createServer(requestListener) {\n  return new Server(requestListener);\n}\n</code></pre><p>那么，马上进入 <strong>lib/_http_server.js</strong> 看吧。</p>\n<p>首先是创建一个 HttpParser 并绑上监听获取到 HTTP 数据包后解析结果的回调函数的代码：</p>\n<pre class=\"prettyprint language-js\"><code>const {\n  parsers,\n  ...\n} = require(&#x27;_http_common&#x27;);\n\nfunction connectionListener(socket) {\n  ...\n\n  var parser = parsers.alloc();\n  parser.reinitialize(HTTPParser.REQUEST);\n  parser.socket = socket;\n  socket.parser = parser;\n  parser.incoming = null;\n\n  ...\n\n  state.onData = socketOnData.bind(undefined, this, socket, parser, state);\n  ...\n  socket.on(&#x27;data&#x27;, state.onData);\n\n  ...\n}\n\nfunction socketOnData(server, socket, parser, state, d) {\n  assert(!socket._paused);\n  debug(&#x27;SERVER socketOnData %d&#x27;, d.length);\n\n  var ret = parser.execute(d);\n  onParserExecuteCommon(server, socket, parser, state, ret, d);\n}\n</code></pre><p>从源码中文我们能看到，当一个 HTTP 请求过来的时候，监听函数 <code>connectionListener()</code> 会拿着 Socket 对象加上一个 <code>data</code> 事件监听——一旦有请求连接过来，就去执行 <code>socketOnData()</code> 函数。</p>\n<p>而在 <code>socketOnData()</code> 函数中，做的主要事情就是 <code>parser.execute(d)</code> 来解析 HTTP 数据包，在解析完成后执行一下回调函数 <code>onParserExecuteCommon()</code>。</p>\n<p>至于这个 <code>parser</code>，我们能看到它是从 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/lib/_http_common.js#L170-L193\"><strong>lib/_http_common.js</strong></a> 中来的。</p>\n<pre class=\"prettyprint language-js\"><code>var parsers = new FreeList(&#x27;parsers&#x27;, 1000, function() {\n  var parser = new HTTPParser(HTTPParser.REQUEST);\n\n  ...\n\n  parser[kOnHeaders] = parserOnHeaders;\n  parser[kOnHeadersComplete] = parserOnHeadersComplete;\n  parser[kOnBody] = parserOnBody;\n  parser[kOnMessageComplete] = parserOnMessageComplete;\n  parser[kOnExecute] = null;\n\n  return parser;\n});\n</code></pre><p>能看出来 <code>parsers</code> 是 <code>HTTPParser</code> 的一条 Free List（效果类似于最简易的动态内存池），每个 Parser 在初始化的时候绑定上了各种回调函数。具体的一些回调函数就不细讲了，有兴趣的童鞋可自行翻阅。</p>\n<p>这么一来，链路就比较明晰了：</p>\n<p><strong>请求进来的时候，Server 对象会为该次请求的 Socket 分配一个 <code>HttpParser</code> 对象，并调用其 <code>execute()</code> 函数进行解析，在解析完成后调用 <code>onParserExecuteCommon()</code> 函数。</strong></p>\n<h3>node_http_parser.cc</h3>\n<p>我们在 <strong>lib/_http_common.js</strong> 中能发现，<code>HTTPParser</code> 的实现存在于 <strong>src/node_http_parser.cc</strong> 中：</p>\n<pre class=\"prettyprint language-js\"><code>const binding = process.binding(&#x27;http_parser&#x27;);\nconst { methods, HTTPParser } = binding;\n</code></pre><blockquote>\n<p>至于为什么 <code>const binding = process.binding('http_parser')</code> 就是对应到 <strong>src/node_http_parser.cc</strong> 文件，以及这一小节中下面的一些 C++ 源码相关分析，不明白且有兴趣的童鞋可自行去阅读更深一层的源码，或者网上搜索答案，或者我提前无耻硬广一下我快要上市的书《Node.js：来一打 C++ 扩展》——里面也有说明，以及我的有一场知乎 Live《深入理解 Node.js 包与模块机制》。</p>\n</blockquote>\n<p>总而言之，我们接下去要看的就是 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/src/node_http_parser.cc#L796-L804\"><strong>src/node_http_parser.cc</strong></a> 了。</p>\n<pre class=\"prettyprint language-cpp\"><code>env-&gt;SetProtoMethod(t, &quot;close&quot;, Parser::Close);\nenv-&gt;SetProtoMethod(t, &quot;execute&quot;, Parser::Execute);\nenv-&gt;SetProtoMethod(t, &quot;finish&quot;, Parser::Finish);\nenv-&gt;SetProtoMethod(t, &quot;reinitialize&quot;, Parser::Reinitialize);\nenv-&gt;SetProtoMethod(t, &quot;pause&quot;, Parser::Pause&lt;true&gt;);\nenv-&gt;SetProtoMethod(t, &quot;resume&quot;, Parser::Pause&lt;false&gt;);\nenv-&gt;SetProtoMethod(t, &quot;consume&quot;, Parser::Consume);\nenv-&gt;SetProtoMethod(t, &quot;unconsume&quot;, Parser::Unconsume);\nenv-&gt;SetProtoMethod(t, &quot;getCurrentBuffer&quot;, Parser::GetCurrentBuffer);\n</code></pre><p>如代码片段所示，前文中 <code>parser.execute()</code> 所对应的函数就是 <code>Parser::Execute()</code> 了。</p>\n<pre class=\"prettyprint language-cpp\"><code>class Parser : public AsyncWrap {\n  ...\n\n  static void Execute(const FunctionCallbackInfo&lt;Value&gt;&amp; args) {\n    Parser* parser;\n    ...\n\n    Local&lt;Object&gt; buffer_obj = args[0].As&lt;Object&gt;();\n    char* buffer_data = Buffer::Data(buffer_obj);\n    size_t buffer_len = Buffer::Length(buffer_obj);\n\n    ...\n\n    Local&lt;Value&gt; ret = parser-&gt;Execute(buffer_data, buffer_len);\n\n    if (!ret.IsEmpty())\n      args.GetReturnValue().Set(ret);\n  }\n\n  Local&lt;Value&gt; Execute(char* data, size_t len) {\n    EscapableHandleScope scope(env()-&gt;isolate());\n\n    current_buffer_len_ = len;\n    current_buffer_data_ = data;\n    got_exception_ = false;\n\n    size_t nparsed =\n      http_parser_execute(&amp;parser_, &amp;settings, data, len);\n\n    Save();\n\n    &#x2F;&#x2F; Unassign the &#x27;buffer_&#x27; variable\n    current_buffer_.Clear();\n    current_buffer_len_ = 0;\n    current_buffer_data_ = nullptr;\n\n    &#x2F;&#x2F; If there was an exception in one of the callbacks\n    if (got_exception_)\n      return scope.Escape(Local&lt;Value&gt;());\n\n    Local&lt;Integer&gt; nparsed_obj = Integer::New(env()-&gt;isolate(), nparsed);\n    &#x2F;&#x2F; If there was a parse error in one of the callbacks\n    &#x2F;&#x2F; TODO(bnoordhuis) What if there is an error on EOF?\n    if (!parser_.upgrade &amp;&amp; nparsed != len) {\n      enum http_errno err = HTTP_PARSER_ERRNO(&amp;parser_);\n\n      Local&lt;Value&gt; e = Exception::Error(env()-&gt;parse_error_string());\n      Local&lt;Object&gt; obj = e-&gt;ToObject(env()-&gt;isolate());\n      obj-&gt;Set(env()-&gt;bytes_parsed_string(), nparsed_obj);\n      obj-&gt;Set(env()-&gt;code_string(),\n               OneByteString(env()-&gt;isolate(), http_errno_name(err)));\n\n      return scope.Escape(e);\n    }\n    return scope.Escape(nparsed_obj);\n  }\n}\n</code></pre><p>首先进入 <code>Parser</code> 的静态 <code>Execute()</code> 函数，我们看到它把传进来的 <code>Buffer</code> 转化为 C++ 下的 <code>char*</code> 指针，并记录其数据长度，同时去执行当前调用的 <code>parser</code> 对象所对应的 <code>Execute()</code> 函数。</p>\n<p>在这个 <code>Execute()</code> 函数中，有个最重要的代码，就是：</p>\n<pre class=\"prettyprint language-cpp\"><code>size_t nparsed =\n    http_parser_execute(&amp;parser_, &amp;settings, data, len);\n</code></pre><p>这段代码是调用真正解析 HTTP 数据包的函数，它是 Node.js 这个项目的一个自研依赖，叫 <a href=\"https://github.com/nodejs/node/tree/v8.9.2/deps/http_parser\">http-parser</a>。它独立的项目地址在 <a href=\"https://github.com/nodejs/http-parser\">https://github.com/nodejs/http-parser</a>，我们本文中用的是 Node.js v8.9.2 中所依赖的源码，应该会有偏差。</p>\n<h3>http-parser</h3>\n<h4>HTTP Request 数据包体</h4>\n<blockquote>\n<p>如果你已经对 HTTP 包体了解了，可以略过这一节。</p>\n</blockquote>\n<p>HTTP 的 Request 数据包其实是文本格式的，在 Raw 的状态下，大概是以这样的形式存在：</p>\n<pre class=\"prettyprint\"><code>方法 URI HTTP&#x2F;版本\n头1: 我是头1\n头2: 我是头2\n</code></pre><blockquote>\n<p>简单起见，这里就写出最基础的一些内容，至于 Body 什么的大家自己找资料看吧。</p>\n</blockquote>\n<p>上面的是什么意思呢？我们看看 CURL 的结果就知道了，实际上对应 <code>curl ... -v</code> 的中间输出：</p>\n<pre class=\"prettyprint\"><code>GET &#x2F;test HTTP&#x2F;1.1\nHost: 127.0.0.1:5555\nUser-Agent: curl&#x2F;7.54.0\nAccept: *&#x2F;*\n</code></pre><p>所以实际上大家平时在文章中、浏览器调试工具中看到的什么请求头啊什么的，都是以文本形式存在的，以换行符分割。</p>\n<p>而——重点来了，导致我们本文所述“Bug”出现的请求，它的请求包如下：</p>\n<pre class=\"prettyprint\"><code>GET &#x2F;foo bar HTTP&#x2F;1.1\nHost: 127.0.0.1:5555\nUser-Agent: curl&#x2F;7.54.0\nAccept: *&#x2F;*\n</code></pre><p>重点在第一行：</p>\n<pre class=\"prettyprint\"><code>GET &#x2F;foo bar HTTP&#x2F;1.1\n</code></pre><h4>源码解析</h4>\n<p>话不多少，我们之间前往 http-parser 的 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/deps/http_parser/http_parser.c#L634\">http_parser.c</a> 看 <code>http_parser_execute ()</code> 函数中的状态机变化。</p>\n<p>从源码中文我们能看到，http-parser 的流程是从头到尾以 O(n) 的时间复杂度对字符串逐字扫描，并且不后退也不往前跳。</p>\n<p>那么扫描到每个字符的时候，都有属于当前的一个状态，如“正在扫描处理 uri”、“正在扫描处理 HTTP 协议并且处理到了 H”、“正在扫描处理 HTTP 协议并且处理到了 HT”、“正在扫描处理 HTTP 协议并且处理到了 HTT”、“正在扫描处理 HTTP 协议并且处理到了 HTTP”、……</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/a15b4afegy1fmf459xnmvj208c05w762\" alt=\"这是回音你懂吗\"></p>\n<p>憋笑，这是真的，我们看看代码就知道了：</p>\n<pre class=\"prettyprint language-c\"><code>case s_req_server:\ncase s_req_server_with_at:\ncase s_req_path:\ncase s_req_query_string_start:\ncase s_req_query_string:\ncase s_req_fragment_start:\ncase s_req_fragment:\n{\n  switch (ch) {\n    case &#x27; &#x27;:\n      UPDATE_STATE(s_req_http_start);\n      CALLBACK_DATA(url);\n      break;\n    case CR:\n    case LF:\n      parser-&gt;http_major = 0;\n      parser-&gt;http_minor = 9;\n      UPDATE_STATE((ch == CR) ?\n        s_req_line_almost_done :\n        s_header_field_start);\n      CALLBACK_DATA(url);\n      break;\n    default:\n      UPDATE_STATE(parse_url_char(CURRENT_STATE(), ch));\n      if (UNLIKELY(CURRENT_STATE() == s_dead)) {\n        SET_ERRNO(HPE_INVALID_URL);\n        goto error;\n      }\n  }\n  break;\n}\n</code></pre><p>在扫描的时候，如果当前状态是 URI 相关的（如 <code>s_req_path</code>、<code>s_req_query_string</code> 等），则执行一个子 <code>switch</code>，里面的处理如下：</p>\n<ul>\n<li>若当前字符是空格，则将状态改变为 <code>s_req_http_start</code> 并认为 URI 已经解析好了，通过宏 <code>CALLBACK_DATA()</code> 触发 URI 解析好的事件；</li>\n<li>若当前字符是换行符，则说明还在解析 URI 的时候就被换行了，后面就不可能跟着 HTTP 协议版本的申明了，所以设置默认的 HTTP 版本为 <code>0.9</code>，并修改当前状态，最后认为 URI 已经解析好了，通过宏 <code>CALLBACK_DATA()</code> 触发 URI 解析好的事件；</li>\n<li>其余情况（所有其它字符）下，通过调用 <code>parse_url_char()</code> 函数来解析一些东西并更新当前状态。（因为哪怕是在解析 URI 状态中，也还有各种不同的细分，如 <code>s_req_path</code>、<code>s_req_query_string</code> ）</li>\n</ul>\n<p>这里的重点还是当状态为解析 URI 的时候遇到了空格的处理，上面也解释过了，一旦遇到这种情况，则会认为 URI 已经解析好了，并且将状态修改为 <code>s_req_http_start</code>。也就是说，有“Bug”的那个数据包\n<code>GET /foo bar HTTP/1.1</code> 在解析到 <code>foo</code> 后面的空格的时候它就将状态改为 <code>s_req_http_start</code> 并且认为 URI 已经解析结束了。</p>\n<p>好的，接下来我们看看 <code>s_req_http_start</code> 怎么处理：</p>\n<pre class=\"prettyprint language-c\"><code>case s_req_http_start:\n  switch (ch) {\n    case &#x27;H&#x27;:\n      UPDATE_STATE(s_req_http_H);\n      break;\n    case &#x27; &#x27;:\n      break;\n    default:\n      SET_ERRNO(HPE_INVALID_CONSTANT);\n      goto error;\n  }\n  break;\n\ncase s_req_http_H:\n  STRICT_CHECK(ch != &#x27;T&#x27;);\n  UPDATE_STATE(s_req_http_HT);\n  break;\n\ncase s_req_http_HT:\n  ...\n\ncase s_req_http_HTT:\n  ...\n\ncase s_req_http_HTTP:\n  ...\n\ncase s_req_first_http_major:\n  ...\n</code></pre><p>如代码所见，若当前状态为 <code>s_req_http_start</code>，则先判断当前字符是不是合标。因为就 HTTP 请求包体的格式来看，如果 URI 解析结束的话，理应出现类似 <code>HTTP/1.1</code> 的这么一个版本申明。所以这个时候 http-parser 会直接判断当前字符是否为 <code>H</code>。</p>\n<ul>\n<li>若是 <code>H</code>，则将状态改为 <code>s_req_http_H</code> 并继续扫描循环的下一位，同理在 <code>s_req_http_H</code> 下若合法状态就会变成 <code>s_req_http_HT</code>，以此类推；\n+若是空格，则认为是多余的空格，那么当前状态不做任何改变，并继续下一个扫描；</li>\n<li>但如果当前字符既不是空格也不是 <code>H</code>，那么好了，http-parser 直接认为你的请求包不合法，将你本次的解析设置错误 <code>HPE_INVALID_CONSTANT</code> 并 <code>goto</code> 到 <code>error</code> 代码块。</li>\n</ul>\n<p>至此，我们基本上已经明白了原因了：</p>\n<p><strong>http-parser 认为在 HTTP 请求包体中，第一行的 URI 解析阶段一旦出现了空格，就会认为 URI 解析完成，继而解析 HTTP 协议版本。但若此时紧跟着的不是 HTTP 协议版本的标准格式，http-parser 就会认为你这是一个 <code>HPE_INVALID_CONSTANT</code> 的数据包。</strong></p>\n<p>不过，我们还是继续看看它的 <code>error</code> 代码块吧：</p>\n<pre class=\"prettyprint language-c\"><code>error:\n  if (HTTP_PARSER_ERRNO(parser) == HPE_OK) {\n    SET_ERRNO(HPE_UNKNOWN);\n  }\n\n  RETURN(p - data);\n</code></pre><p>这段代码中首先判断一下当跳到这段代码的时候有没有设置错误，若没有设置错误则将错误设置为未知错误（<code>HPE_UNKNOWN</code>），然后返回已解析的数据包长度。</p>\n<blockquote>\n<p><code>p</code> 是当前解析字符指针，<code>data</code> 是这个数据包的起始指针，所以 <code>p - data</code> 就是已解析的数据长度。如果成功解析完，这个数据包理论上是等于这个数据包的完整长度，若不等则理论上说明肯定是中途出错提前返回。</p>\n</blockquote>\n<h3>回到 node_http_parser.cc</h3>\n<p>看完了 http-parser 的原理后，很多地方茅塞顿开。现在我们回到它的调用地 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/src/node_http_parser.cc#L630-L666\"><strong>node_http_parser.cc</strong></a> 继续阅读吧。</p>\n<pre class=\"prettyprint language-cpp\"><code>Local&lt;Value&gt; Execute(char* data, size_t len) {\n  ...\n\n  size_t nparsed =\n    http_parser_execute(&amp;parser_, &amp;settings, data, len);\n\n  Local&lt;Integer&gt; nparsed_obj = Integer::New(env()-&gt;isolate(), nparsed);\n  if (!parser_.upgrade &amp;&amp; nparsed != len) {\n    enum http_errno err = HTTP_PARSER_ERRNO(&amp;parser_);\n\n    Local&lt;Value&gt; e = Exception::Error(env()-&gt;parse_error_string());\n    Local&lt;Object&gt; obj = e-&gt;ToObject(env()-&gt;isolate());\n    obj-&gt;Set(env()-&gt;bytes_parsed_string(), nparsed_obj);\n    obj-&gt;Set(env()-&gt;code_string(),\n             OneByteString(env()-&gt;isolate(), http_errno_name(err)));\n\n    return scope.Escape(e);\n  }\n  return scope.Escape(nparsed_obj);\n}\n</code></pre><p>从调用处我们能看见，在执行完 <code>http_parser_execute()</code> 后有一个判断，若当前请求不是 <code>upgrade</code> 请求（即请求头中有说明 <code>Upgrade</code>，通常用于 WebSocket），并且解析长度不等于原数据包长度（前文说了这种情况属于出错了）的话，那么进入中间的错误代码块。</p>\n<p>在错误代码块中，先 <code>HTTP_PARSER_ERRNO(&amp;parser_)</code> 拿到错误码，然后通过 <code>Exception::Error()</code> 生成错误对象，将错误信息塞进错误对象中，最后返回错误对象。</p>\n<p>如果没错，则返回解析长度（<code>nparsed_obj</code> 即 <code>nparsed</code>）。</p>\n<blockquote>\n<p>在这个文件中，眼尖的童鞋可能发现了，执行 <code>Execute()</code> 有好多处，这是因为实际上一个 HTTP 请求可能是流式的，所以有时候可能会只拿到部分数据包。所以最后有一个结束符需要被确认。<strong>这也是为什么 http-parser 在解析的时候只能逐字解析而不能跳跃或者后退了。</strong></p>\n</blockquote>\n<h3>回到 _http_server.js</h3>\n<p>我们把 <code>Parser::Execute()</code> 也就是 JavaScript 代码中的 <code>parser.execute()</code> 给搞清楚后，我们就能回到 <a href=\"https://github.com/nodejs/node/blob/v8.9.2/lib/_http_server.js#L462-L507\">_http_server.js</a> 看代码了。</p>\n<p>前文说了，<code>socketOnData</code> 在解析完数据包后会执行 <code>onParserExecuteCommon</code> 函数，现在就来看看这个 <code>onParserExecuteCommon()</code> 函数。</p>\n<pre class=\"prettyprint language-js\"><code>function onParserExecuteCommon(server, socket, parser, state, ret, d) {\n  resetSocketTimeout(server, socket, state);\n\n  if (ret instanceof Error) {\n    debug(&#x27;parse error&#x27;, ret);\n    socketOnError.call(socket, ret);\n  } else if (parser.incoming &amp;&amp; parser.incoming.upgrade) {\n    ...\n  }\n}\n</code></pre><p>长长的一个函数被我精简成这么几句话，重点很明显。<code>ret</code> 就是从 <code>socketOnData</code> 传进来已解析的数据长度，但是在 C++ 代码中我们也看到了它还有可能是一个错误对象。所以在这个函数中一开始就做了一个判断，判断解析的结果是不是一个错误对象，如果是错误对象则调用 <code>socketOnError()</code>。</p>\n<pre class=\"prettyprint language-js\"><code>function socketOnError(e) {\n  &#x2F;&#x2F; Ignore further errors\n  this.removeListener(&#x27;error&#x27;, socketOnError);\n  this.on(&#x27;error&#x27;, () =&gt; {});\n\n  if (!this.server.emit(&#x27;clientError&#x27;, e, this))\n    this.destroy(e);\n}\n</code></pre><p>我们看到，如果真的不小心走到这一步的话，HTTP Server 对象会触发一个 <code>clientError</code> 事件。</p>\n<p>整个事情串联起来了：</p>\n<ul>\n<li>收到请求后会通过 http-parser 解析数据包；</li>\n<li><code>GET /foo bar HTTP/1.1</code> 会被解析出错并返回一个错误对象；</li>\n<li>错误对象会进入 <code>if (ret instanceof Error)</code> 条件分支并调用 <code>socketOnError()</code> 函数；</li>\n<li><code>socketOnError()</code> 函数中会对服务器触发一个 <code>clientError</code> 事件；（<code>this.server.emit('clientError', e, this)</code>）</li>\n<li><strong>至此，HTTP Server 并不会走到你的那个 <code>function(req, resp)</code> 中去，所以不会有任何的数据被返回就结束了，也就解答了一开始的问题——收不到任何数据就请求结束。</strong></li>\n</ul>\n<p>这就是我要逐级进来看代码，而不是直达 http-parser 的原因了——<code>clientError</code> 是一个关键。</p>\n<h2>处理办法</h2>\n<p>要解决这个“Bug”其实不难，直接监听 <a href=\"https://nodejs.org/api/http.html#http_event_clienterror\"><code>clientError</code> 事件</a>并做一些处理即可。</p>\n<pre class=\"prettyprint language-js\"><code>&#x27;use strict&#x27;;\n\nconst http = require(&#x27;http&#x27;);\n\nconst server = http.createServer(function(req, resp) {\n    console.log(&#x27;🌚&#x27;);\n    resp.end(&#x27;hello world&#x27;);\n}).on(&#x27;clientError&#x27;, function(err, sock) {\n    console.log(&#x27;🐷&#x27;);\n    sock.end(&#x27;HTTP&#x2F;1.1 400 Bad Request\\r\\n\\r\\n&#x27;);\n});\n\nserver.listen(5555);\n</code></pre><blockquote>\n<p>**注意：**由于运行到 <code>clientError</code> 事件时，并没有任何 Request 和 Response 的封装，你能拿到的是一个 Node.js 中原始的 Socket 对象，所以当你要返回数据的时候需要自己按照 HTTP 返回数据包的格式来输出。</p>\n</blockquote>\n<p>这个时候再挥起你的小手试一下 CURL 吧：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;127.0.0.1:5555&#x2F;d d&#x27; -v\n*   Trying 127.0.0.1...\n* TCP_NODELAY set\n* Connected to 127.0.0.1 (127.0.0.1) port 5555 (#0)\n&gt; GET &#x2F;d d HTTP&#x2F;1.1\n&gt; Host: 127.0.0.1:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n&lt; HTTP&#x2F;1.1 400 Bad Request\n* no chunk, no close, no size. Assume close to signal end\n&lt;\n* Closing connection 0\n</code></pre><p>如愿以偿地输出了 400 状态码。</p>\n<h2>引申</h2>\n<p>接下来我们要引申讨论的一个点是，为什么这货不是一个真正意义上的 Bug。</p>\n<p>首先我们看看 Nginx 这么实现这个黑科技的吧。</p>\n<h3>Nginx 实现</h3>\n<p>打开 Nginx 源码的<a href=\"https://github.com/nginx/nginx/blob/release-1.13.7/src/http/ngx_http_parse.c#L104\">相应位置</a>。</p>\n<p>我们能看到它的状态机对于 URI 和 HTTP 协议声明中间多了一个中间状态，叫 <code>sw_check_uri_http_09</code>，专门处理 URI 后面的空格。</p>\n<p>在各种 URI 解析状态中，基本上都能找到这么一句话，表示若当前状态正则解析 URI 的各种状态并且遇到空格的话，则将状态改为 <code>sw_check_uri_http_09</code>。</p>\n<pre class=\"prettyprint language-c\"><code>case sw_check_uri:\n  switch (ch) {\n  case &#x27; &#x27;:\n    r-&gt;uri_end = p;\n    state = sw_check_uri_http_09;\n    break;\n\n  ...\n  }\n\n  ...\n</code></pre><p>然后在 <code>sw_check_uri_http_09</code> 状态时会做一些检查：</p>\n<pre class=\"prettyprint language-c\"><code>case sw_check_uri_http_09:\n    switch (ch) {\n    case &#x27; &#x27;:\n        break;\n    case CR:\n        r-&gt;http_minor = 9;\n        state = sw_almost_done;\n        break;\n    case LF:\n        r-&gt;http_minor = 9;\n        goto done;\n    case &#x27;H&#x27;:\n        r-&gt;http_protocol.data = p;\n        state = sw_http_H;\n        break;\n    default:\n        r-&gt;space_in_uri = 1;\n        state = sw_check_uri;\n        p--;\n        break;\n    }\n    break;\n</code></pre><p>例如：</p>\n<ul>\n<li>遇到空格则继续保持当前状态开始扫描下一位；</li>\n<li>如果是换行符则设置默认 HTTP 版本并继续扫描；</li>\n<li>如果遇到的是 <code>H</code> 才修改状态为 <code>sw_http_H</code> 认为接下去开始 HTTP 版本扫描；</li>\n<li>如果是其它字符，则标明一下 URI 中有空格，然后将状态改回 <code>sw_check_uri</code>，然后倒退回一格以 <code>sw_check_uri</code> 继续扫描当前的空格。</li>\n</ul>\n<p>在理解了这个“黑科技”后，我们很快能找到一个很好玩的点，开启你的 Nginx 并用 CURL 请求以下面的例子一下它看看吧：</p>\n<pre class=\"prettyprint\"><code>$ curl &#x27;http:&#x2F;&#x2F;xcoder.in:5555&#x2F;d H&#x27; -v\n*   Trying 103.238.225.181...\n* TCP_NODELAY set\n* Connected to xcoder.in (103.238.225.181) port 5555 (#0)\n&gt; GET &#x2F;d H HTTP&#x2F;1.1\n&gt; Host: xcoder.in:5555\n&gt; User-Agent: curl&#x2F;7.54.0\n&gt; Accept: *&#x2F;*\n&gt;\n&lt; HTTP&#x2F;1.1 400 Bad Request\n&lt; Server: openresty&#x2F;1.11.2.1\n&lt; Date: Tue, 12 Dec 2017 11:18:13 GMT\n&lt; Content-Type: text&#x2F;html\n&lt; Content-Length: 179\n&lt; Connection: close\n&lt;\n&lt;html&gt;\n&lt;head&gt;&lt;title&gt;400 Bad Request&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;\n&lt;body bgcolor=&quot;white&quot;&gt;\n&lt;center&gt;&lt;h1&gt;400 Bad Request&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;\n&lt;hr&gt;&lt;center&gt;openresty&#x2F;1.11.2.1&lt;&#x2F;center&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n* Closing connection 0\n</code></pre><p>怎么样？是不是发现结果跟之前的不一样了——它居然也返回了 400 Bad Request。</p>\n<p>原因为何就交给童鞋们自己考虑吧。</p>\n<h3>RFC 2616 与 RFC 2396</h3>\n<p>那么，为什么即使在 Nginx 支持空格 URI 的情况下，我还说 Node.js 这个不算 Bug，并且指明 Nginx 是“黑科技”呢？</p>\n<p>后来我去看了 HTTP 协议 RFC。</p>\n<p>原因在于 Network Working Group 的 <a href=\"http://www.ietf.org/rfc/rfc2616.txt\">RFC 2616</a>，关于 HTTP 协议的规范。</p>\n<p>在 RFC 2616 的 <a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.2.1\">3.2.1 节</a>中做了一些说明，它说了在 HTTP 协议中关于 URI 的文法和语义参照了 <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a>。</p>\n<blockquote>\n<p>URIs in HTTP can be represented in absolute form or relative to some known base URI, depending upon the context of their use. The two forms are differentiated by the fact that absolute URIs always begin with a scheme name followed by a colon. For definitive information on URL syntax and semantics, see “Uniform Resource Identifiers (URI): Generic Syntax and Semantics,” RFC 2396 (which replaces RFCs 1738 and RFC 1808). This specification adopts the definitions of “URI-reference”, “absoluteURI”, “relativeURI”, “port”, “host”,“abs_path”, “rel_path”, and “authority” from that specification.</p>\n</blockquote>\n<p>而在 <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a> 中，我们同样找到了它的 <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">2.4.3 节</a>。里面对于 Disallow 的 US-ASCII 字符做了解释，其中有：</p>\n<ul>\n<li>\n<p>控制符，指 ASCII 码在 0x00-0x1F 范围内以及 0x7F；</p>\n<p>控制符通常不可见；</p>\n</li>\n<li>\n<p>空格，指 0x20；</p>\n<p>空格不可控，如经由一些排版软件转录后可能会有变化，&lt;span style=“color: #ccc;”&gt;而到了 HTTP 协议这层时，反正空格不推荐使用了，所以就索性用空格作为首行分隔符了；&lt;/span&gt;</p>\n</li>\n<li>\n<p>分隔符，<code>&quot;&lt;&quot;</code>、<code>&quot;&gt;&quot;</code>、<code>&quot;#&quot;</code>、<code>&quot;%&quot;</code>、<code>&quot;\\&quot;&quot;</code>。</p>\n<p>如 <code>#</code> 将用于浏览器地址栏的 Hash；而 <code>%</code> 则会与 URI 转义一同使用，所以不应单独出现在 URI 中。</p>\n</li>\n</ul>\n<p><strong>于是乎，HTTP 请求中，包体的 URI 似乎本就不应该出现空格，而 Nginx 是一个黑魔法的姿势。</strong></p>\n<h2>小结</h2>\n<p>嚯，写得累死了。本次的一个探索基于了一个有空格非正常的 URI 通过 CURL 或者其它一些客户端请求时，Node.js 出现的 Bug 状态。</p>\n<blockquote>\n<p>实际上发现这个 Bug 的时候，客户端请求似乎是因为那边的开发者手抖，不小心将不应该拼接进来的内容给拼接到了 URL 中，类似于 <code>$ rm -rf /</code>。</p>\n</blockquote>\n<p>一开始我以为这是 Node.js 的 Bug，在探寻之后发现是因为我们自己没用 Node.js HTTP Server 提供的 <code>clientError</code> 事件做正确的处理。而 Nginx 的正常请求则是它的黑科技。这些答案都能从 RFC 中寻找——<strong>再次体现了遇到问题看源码看规范的重要性。</strong></p>\n<p>另，我本打算给 http-parser 也加上黑魔法，后来我快写好的时候发现它是流式的，很多状态没法在现有的体系中保留下来，最后放弃了，反正这也不算 Bug。不过在以后有时间的时候，感觉还是可以好好整理一下代码，好好修改一下给提个 PR 上去，以此自勉。</p>\n<p>最后，求 fafa。</p>\n<p><img src=\"http://ww2.sinaimg.cn/bmiddle/a15b4afely1fme81d41wpg206o06oabl\" alt=\"求 fafa\"></p>\n<h2>交流</h2>\n<p>如果你有更多的想法，或者想了解蚂蚁金服的 Node.js、前端以及设计小伙伴们的更多姿势，可以报名首届蚂蚁体验科技大会 SEE Conf，比如有死马大大的《Developer Experience First —— Techless Web Application 的理念与实践》，还有青栀大大的《蚂蚁开发者工具，服务蚂蚁生态的移动研发 IDE》等等。</p>\n<p>报名官网：<a href=\"https://seeconf.alipay.com/\">https://seeconf.alipay.com/</a></p>\n<p>期待您的光临。</p>\n</div>",
            "title": "Node.js 中遇到含空格 URL 的神奇“Bug”——小范围深入 HTTP 协议",
            "last_reply_at": "2018-01-29T02:52:14.077Z",
            "good": true,
            "top": false,
            "reply_count": 23,
            "visit_count": 2450,
            "create_at": "2017-12-13T06:11:30.129Z",
            "author": {
                "loginname": "xadillax",
                "avatar_url": "https://avatars3.githubusercontent.com/u/2842176?v=4&s=120"
            }
        }, {
            "id": "5a6ae0b99288dc815328826a",
            "author_id": "5775bd840b982e0450b7463e",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>我需要在vue项目运行时引入新的vue文件，该文件是服务器生成的通过ajax请求回去的，请问如何实现这个功能？</p>\n</div>",
            "title": "vue这么动态引入vue文件？",
            "last_reply_at": "2018-01-29T02:20:33.363Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 352,
            "create_at": "2018-01-26T08:03:05.836Z",
            "author": {
                "loginname": "mcck",
                "avatar_url": "https://avatars.githubusercontent.com/u/20223048?v=3&s=120"
            }
        }, {
            "id": "5a6b566e9d371d4a059eeef1",
            "author_id": "59413aaa8ce045ee166a1544",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>就在最近，我完成了Parse JavaScript SDK指南的翻译，并在指南中加入了一些教程、示例，以保证新手能够快速上手。</p>\n<p>我在QQ群里面贴出<a href=\"https://parse-zh.buzhundong.com/\">地址</a>宣传了下，然后发现大部分人听都没听说过Parse，果然，我是站在潮流之巅的弄潮儿啊hhhhhh~</p>\n<p>那么，Parse到底是什么？</p>\n<p>三个字就可以概括：去后端。</p>\n<p>Parse服务其实已经推出很多年了，在4年前被Facebook 8500万美元收购，在去年被Facebook开源，但是在国内几乎一直无人问津。</p>\n<p>国内同类的服务平台，即BasS(Backend as a Service)服务平台主流的有Leancloud、Bmob。</p>\n<p>其中Leancloud我使用过，Bmob也注册过。Leancloud达到免费阈值以后的收费方案是每天最低消费30元，Bmob达到免费阈值以后的收费方案有99元/月的套餐。对于原型开发阶段的应用，其服务的免费额度使用还是绰绰有余的。</p>\n<p>就像刚才说的，BaaS服务就是去后端，也就是说，后端几乎完全不需要你自己开发了，数据库、用户系统、安全系统、Hook回调、API查询等都为你搭建好了。而且，比你搭建的还好。你只需要在项目中集成SDK，然后直接调用方法传参就可以完成前后端交互。</p>\n<p>打个比方，我要写一个按钮的用户注册方法：</p>\n<pre class=\"prettyprint language-js\"><code>&#x2F;&#x2F;集成SDK\nimport parse from &#x27;parse&#x27;\nparse.serverURL = &#x27;http:&#x2F;&#x2F;localhost:2018&#x2F;parse&#x27;\nparse.initialize(&#x27;myAppId&#x27;, &#x27;123456&#x27;)\n\n&#x2F;&#x2F;在按钮点击实践中调用注册方法：\nbutton.on(&#x27;click&#x27;,function(username,password){\n  let user = new parse.User()\n  user.set(&#x27;username&#x27;, &#x27;000001&#x27;)\n  user.set(&#x27;password&#x27;, &#x27;lzhlmcl,yhblsqt&#x27;)\n  user.set(&#x27;email&#x27;, &#x27;xxxxx@qq.com&#x27;)\n  user.signUp().then(user =&gt; {\n  alert(&#x27;注册成功&#x27;)\n}).catch(console.error)\n})\n</code></pre><p>完成！</p>\n<p>只需要十几行代码，不需要写后端和接口。当上面代码弹出注册成功后，后台还会发送验证邮箱的邮件给用户，然后后台数据库就会出现新注册的用户。</p>\n<p>怎么样，so easy吧。</p>\n<p>简直就是，前端抢后端饭碗系列。</p>\n<p>当然了，使用Leancloud、Bmob这样的商业服务平台，数据是存储在他们的服务器上的。使用Parse自己搭建后端，则是保存在自己的服务器上。</p>\n<p>对比一下：</p>\n<p>Parse开源，数据库绝对私有，完全免费，这是Parse的优点。</p>\n<p>Leancloud、Bmob则是本地化做的非常优秀，比如对微信接口、短信验证的集成，这是他们的优点。</p>\n<p>上述优点，双方都不具备对方的优点，所以，让你选的话，你选胸大的还是腿长的？</p>\n<p>我一般是结合业务，如果我觉得这个应用就是玩玩，肯定做不大，为了省去维护和服务器维护，我会选择使用Leancloud，Bmob不熟练。如果说这个应用以后会有很大访问量，打算认真做做，预期会超过L、B的免费额度，出于平穷限制，我会选择Parse。</p>\n<p>不管你选择哪个，Parse其实都值得你掌握的。</p>\n<p>身为一个前端，如果你会使用L、B，首先也是不错的，至少开发效率很高了；不过，依赖于第三方商业平台，还是不够独立，算不得全栈开发者。如果你会使用Parse，你就相当于快速掌握了一种后端技术栈，算得上是全栈了。</p>\n<p>我为什么这么推荐Parse，并把Parse的文档翻译中文，整合详细的教程和实例呢？Parse是一个开源项目，也不是我的项目，我就是非常喜欢这类框架，你知道，发现一个好东西，总是特别想推荐给朋友们的。</p>\n<p>接下来，我还会继续写几个教程和例子，虽然，不是非常必要，有的人文档过一遍就会用了。</p>\n<p>最后附上<a href=\"https://parse-zh.buzhundong.com/\">Parse JavaScript SDK中文文档地址</a>。</p>\n</div>",
            "title": "[文档翻译] 全栈速成，最适合前端的后端服务框架： Parse",
            "last_reply_at": "2018-01-29T01:51:50.917Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 483,
            "create_at": "2018-01-26T16:25:18.585Z",
            "author": {
                "loginname": "jaweii",
                "avatar_url": "https://avatars3.githubusercontent.com/u/22613580?v=4&s=120"
            }
        }, {
            "id": "5a6a8542ce45d440451463b6",
            "author_id": "580ffe64eae2a24f34e67ee1",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>TypeError: db.collection is not a function</p>\n<p>之后在连接数据库回调中加入 var mydb = db.db(‘myDatabaseNameAsAString’);\n参考：<a href=\"https://stackoverflow.com/questions/43779323/typeerror-db-collection-is-not-a-function\">https://stackoverflow.com/questions/43779323/typeerror-db-collection-is-not-a-function</a>\n<a href=\"https://mongodb.github.io/node-mongodb-native/api-generated/mongoclient.html\">https://mongodb.github.io/node-mongodb-native/api-generated/mongoclient.html</a>\n不太清楚这么写是为什么?</p>\n<p>具体代码:\nvar MongoClient = require(‘mongodb’).MongoClient;\nvar assert = require(‘assert’);\nvar url = ‘mongodb://localhost:27017/test’;\nvar insertDocument = function(db, callback) {\ndb.collection(‘restaurants’).insertOne( {\n“address” : {\n“street” : “2 Avenue”,\n“zipcode” : “10075”,\n“building” : “1480”,\n“coord” : [ -73.9557413, 40.7720266 ]\n},\n“borough” : “Manhattan”,\n“cuisine” : “Italian”,\n“grades” : [\n{\n“date” : new Date(“2014-10-01T00:00:00Z”),\n“grade” : “A”,\n“score” : 11\n},\n{\n“date” : new Date(“2014-01-16T00:00:00Z”),\n“grade” : “B”,\n“score” : 17\n}\n],\n“name” : “Vella”,\n“restaurant_id” : “41704620”\n}, function(err, result) {\nassert.equal(err, null);\nconsole.log(“Inserted a document into the restaurants collection.”);\ncallback();\n});\n};\n// 连接数据库\nMongoClient.connect(url, function(err, db) {\nassert.equal(null, err);\nconsole.log(‘Connected correctly to server.’,db);\nvar mydb = db.db(‘myDatabaseNameAsAString’);\n// 插入数据\ninsertDocument(mydb, function() {\ndb.close();\n});\n});</p>\n</div>",
            "title": "使用 mongodb 遇到的db.collection is not a function",
            "last_reply_at": "2018-01-29T01:29:36.248Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 306,
            "create_at": "2018-01-26T01:32:50.838Z",
            "author": {
                "loginname": "fairyly",
                "avatar_url": "https://avatars1.githubusercontent.com/u/17672815?v=4&s=120"
            }
        }, {
            "id": "59f98c34c8ef9425668ac1fe",
            "author_id": "4f447c2f0a8abae26e01b27d",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><pre class=\"prettyprint language-js\"><code>async function rejectionWithReturnAwait () {\n  try {\n    return await Promise.reject(new Error());\n  } catch (e) {\n    return &#x27;Saved!&#x27;;\n  }\n}\n\nasync function rejectionWithReturn () {\n  try {\n    return Promise.reject(new Error());\n  } catch (e) {\n    return &#x27;Saved!&#x27;;\n  }\n}\n</code></pre></div>",
            "title": "Node 8 LTS 有 async 了很兴奋？ 来，说说这 2 段代码的区别。",
            "last_reply_at": "2018-01-28T23:04:21.964Z",
            "good": false,
            "top": false,
            "reply_count": 23,
            "visit_count": 2443,
            "create_at": "2017-11-01T08:56:20.080Z",
            "author": {
                "loginname": "atian25",
                "avatar_url": "https://avatars1.githubusercontent.com/u/227713?v=3&s=120"
            }
        }, {
            "id": "58d0dd8b17f61387400b7de5",
            "author_id": "575eaa97c1518403160a45c4",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1><a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a></h1>\n<p>Easy-Monitor是一个轻量级的Node项目性能监控工具，能在线上生产环境运行，主要帮助开发者找出执行时间最久或者超出预期的一系列函数，以及运行过程中v8引擎无法优化的一系列函数。</p>\n<p>这个项目源于之前做的解析v8-profiler日志命令行工具，有兴趣的可以看下之前的文章：</p>\n<p><a href=\"https://cnodejs.org/topic/58b562f97872ea0864fee1a7\">手把手测试你的JS代码性能</a></p>\n<p>按照之前所说的方式，对于开发者来说依旧非常的麻烦，并且不能进行线上运行时的调试，所以就整合集成了下诞生了Easy-Monitor。</p>\n<h2>I. 特点</h2>\n<ul>\n<li><strong>轻量级</strong></li>\n<li><strong>运行时</strong></li>\n<li><strong>无状态</strong></li>\n<li><strong>支持线上的cluster模式和多项目部署</strong></li>\n</ul>\n<h2>II. 三步快速开始</h2>\n<h3>安装</h3>\n<p>在控制台执行下面的命令安装：</p>\n<pre class=\"prettyprint language-bash\"><code>npm install easy-monitor\n</code></pre><h3>项目中引入</h3>\n<p>在你的项目入口文件中按照如下方式引入，传入你的项目名称：</p>\n<pre class=\"prettyprint language-js\"><code>const easyMonitor = require(&#x27;easy-monitor&#x27;);\neasyMonitor(&#x27;你的项目名称&#x27;);\n</code></pre><h3>访问监控页面</h3>\n<p>打开你的浏览器，输入以下地址，即可看到进程相关信息：</p>\n<pre class=\"prettyprint language-bash\"><code>http:&#x2F;&#x2F;127.0.0.1:12333\n</code></pre><p>以上三步即可开启你的专属性能监控服务，非常简单！</p>\n<h2>III. 定制化</h2>\n<p><code>Easy-Monitor</code> 也为大家保留了一些重要的属性可以方便定制化，依靠执行 <code>require('easy-monitor')(object)</code> 函数时传入一个对象，来替代默认传入的项目名称的字符串，这个传入的对象可以包含如下属性：</p>\n<ul>\n<li>\n<p><strong>logLevel</strong>：Number类型，默认是2，用来设置日志级别：</p>\n<ul>\n<li>0：不输出任何日志</li>\n<li>1：输出error日志</li>\n<li>2：输出info日志</li>\n<li>3：输出debug日志</li>\n</ul>\n</li>\n<li>\n<p><strong>appName</strong>：String类型，默认是 process.title 获取到的值，用来设置项目名称</p>\n</li>\n<li>\n<p><strong>httpServerPort</strong>：Numver类型，默认是 12333，用来设置监控HTTP服务器的侦听端口</p>\n</li>\n<li>\n<p><strong>filterFunction</strong>：函数，默认将profiling的结果中过滤掉了包含node_modules、anonymous以及路径中不包含 “/” 的系统函数，开发者可以自己编写过滤函数来找出自己想要的结果，入参和返回值：</p>\n<ul>\n<li>filePath：String类型，profiling结果函数所在的文件全路径</li>\n<li>funcName：String类型，pfofiling结果函数的名称</li>\n<li>返回值：为true表示保留结果，false表示过滤掉</li>\n</ul>\n</li>\n<li>\n<p><strong>monitorAuth</strong>：函数，默认不鉴权，用来进行登入监控页面的鉴权，开发者可以自己编写鉴权函数，入参和返回值：</p>\n<ul>\n<li>user：String类型，为用户名</li>\n<li>pass：String类型，为用户键入密码</li>\n<li>返回值：Promise对象实例，resolve(true)表示鉴权通过，resolve(false)或者reject表示鉴权失败</li>\n</ul>\n</li>\n</ul>\n<h2>IV. 监控页面一览</h2>\n<h3>1. 首页</h3>\n<h4>a. 查看整个项目</h4>\n<p><img src=\"//dn-cnode.qbox.me/FnOnNJjc9AsVOMZqevsHqlns7K47\" alt=\"Index_Project.jpeg\"></p>\n<p>如图，点击项目名称，则会对 <strong>整个项目</strong> 所有的进程进行profiling操作，这个所有进程包含：</p>\n<ul>\n<li>单进程模式下则只有一个主进程</li>\n<li>cluster模式下所有的子进程</li>\n</ul>\n<h4>b. 查看项目下某一个子进程</h4>\n<p><img src=\"//dn-cnode.qbox.me/FoW6H8QpWmFDWxEGid4LzXQfL6_I\" alt=\"Index_Pid.jpeg\"></p>\n<p>如图，在cluster模式下项目会有多个子进程，点击某一个特定的pid，则只会对 <strong>此pid对应的子进程</strong> 进行profiling操作。</p>\n<h4>c. 多项目部署</h4>\n<p><img src=\"//dn-cnode.qbox.me/FmR6Bv32tyZR6Rf1yYIy9OF0PKxr\" alt=\"Index_Multi.jpeg\"></p>\n<p>如图，<code>Easy-Monitor</code> <strong>支持多项目部署</strong>，用法和单项目是一模一样的，可以参考前面的快速开始。那么多项目启动后，监控页面会展示出不同的项目名称和对应的子进程pid。</p>\n<h3>2. 监控详情页</h3>\n<h4>a. 执行时间超出预期的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FlaESADt9AZ3ohKXwQeiTfJvCLY7\" alt=\"Detail_Long.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义预期时间以及展示的条数，如下：</p>\n<ul>\n<li><code>?timeout=你预期的时间(ms)</code></li>\n<li><code>?long_limit=你想展示的条数</code></li>\n<li><code>?timeout=你预期的时间(ms)&amp;long_limit=你想展示的条数</code></li>\n</ul>\n<h4>b. 耗费时间最久的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FhpDcFU36iEYUkxC3nvv9bIrRlDY\" alt=\"Detail_Top.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义展示条数，如下：</p>\n<ul>\n<li><code>?top_limit=你想展示的条数</code></li>\n</ul>\n<h4>c. v8引擎无法优化的函数列表</h4>\n<p><img src=\"//dn-cnode.qbox.me/FrBFxsxO8Vle6LFcSha4V10M2lz1\" alt=\"Detail_Bail.jpeg\"></p>\n<p>如图，可以追加 <code>querystring</code> 参数的形式自定义展示条数，如下：</p>\n<ul>\n<li><code>?bail_limit=你想展示的条数</code></li>\n</ul>\n<h2>V. 测试</h2>\n<p><a href=\"https://github.com/hyj1991/easy-monitor\">git clone</a>下本代码后，使用npm安装依赖，然后执行如下测试脚本：</p>\n<pre class=\"prettyprint\"><code>npm run test\n</code></pre><p>即可看到覆盖率测试报告。</p>\n<h2>VI. 结语</h2>\n<p>最后项目地址为：<a href=\"https://github.com/hyj1991/easy-monitor\">Easy-Monitor</a></p>\n<p>欢迎大家提issue，或者一起开发完善，如果感觉不错，赏个star也是很开心的事情~</p>\n</div>",
            "title": "轻量级易部署Node性能监控工具：Easy-Monitor",
            "last_reply_at": "2018-01-28T15:59:20.720Z",
            "good": false,
            "top": false,
            "reply_count": 27,
            "visit_count": 6273,
            "create_at": "2017-03-21T08:00:11.803Z",
            "author": {
                "loginname": "hyj1991",
                "avatar_url": "https://avatars2.githubusercontent.com/u/19908330?v=4&s=120"
            }
        }, {
            "id": "5a6c1d4c9288dc81532882af",
            "author_id": "5a6c18f59288dc81532882ac",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>求一些2018年的前端面试题及侧重的知识点；\n近几年，前端知识迭代很快，面试题也需要推陈出新一下，担心知识点考察不到位</p>\n</div>",
            "title": "求一些2018年的前端面试题及侧重的知识点",
            "last_reply_at": "2018-01-28T15:49:40.888Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 373,
            "create_at": "2018-01-27T06:33:48.627Z",
            "author": {
                "loginname": "andyiwen",
                "avatar_url": "https://avatars0.githubusercontent.com/u/18592006?v=4&s=120"
            }
        }, {
            "id": "5a6c699aafa0a121784a9073",
            "author_id": "598bba38396b25140b58cce4",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h2>jade(pug)</h2>\n<p>由于商标版权问题，Jade 已经改名为了 Pug,github地址<a href>https://github.com/pugjs/pug</a></p>\n<p>Jade 是一个高性能的模板引擎，它是用 JavaScript 实现的，并且可以供 Node 使用,当然还支持其他语言。</p>\n<p>文件后缀名为.pug(.jade)</p>\n<h2>jade优点</h2>\n<ul>\n<li>可读性高</li>\n<li>灵活的缩进</li>\n<li>块展开</li>\n<li>代码默认经过编码处理(转义),安全性高</li>\n<li>运行时和编译时上下文错误报告</li>\n<li>支持命令行编译</li>\n<li>支持html5模式</li>\n<li>在内存中缓存(可选)</li>\n<li>原生支持 Express</li>\n<li>合并动态和静态标签类</li>\n<li>过滤器</li>\n</ul>\n<p>关于Ejs或者其他模板引擎与jade比较,可以看看这篇文章<a href>https://www.zhihu.com/question/20355486</a></p>\n<h2>安装</h2>\n<p>npm安装建议安装个nrm来进行源管理.</p>\n<pre class=\"prettyprint\"><code>npm install pug -g\nnpm install pug-cli -g\n</code></pre><h2>测试demo</h2>\n<p>为了方便编写代码,最好把编译器的tab设置:2.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\n\ndoctype html\nhtml\n  head\n    title jade test\n  body\n    h2 jade study    \n</code></pre><h5>粗暴的编译方法</h5>\n<pre class=\"prettyprint\"><code>pug index.jade\n\n&#x2F;&#x2F; index.html\n&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;jade test&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&lt;body&gt;&lt;h2&gt;jade study    &lt;&#x2F;h2&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;\n</code></pre><p>发现编译后的代码不具备可读性.</p>\n<pre class=\"prettyprint\"><code>pug -- help\n Options:\n     -P, --pretty           compile pretty HTML output ## 输出漂亮结构的HTML\n    -D, --no-debug         compile without debugging (smaller functions) ## 不带调试的编译\n    -w, --watch            watch files for changes and automatically re-render ## 对某个文件的变动保持监控\n    -E, --extension &lt;ext&gt;  specify the output file extension ## 指定输出文件扩展名\n    -s, --silent           do not output logs ## 不输出日志\n   \n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 重新编译\npug -P index.jade\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;head&gt;\n    &lt;title&gt;jade test&lt;&#x2F;title&gt;\n  &lt;&#x2F;head&gt;\n  &lt;body&gt;\n    &lt;h2&gt;jade study    &lt;&#x2F;h2&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h5>自动编译</h5>\n<p>只是为了学习,这里只要设置-w -P .开发中通过打包工具来进行自动编译.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 命令行工具推荐使用Cmder\n\nλ pug -P -w index.jade\n  watching index.jade\n  rendered index.html\n</code></pre><h2>Express与Pug</h2>\n<p>Pug完全集成了一个流行的Node.js Web框架Express，作为支持的视图引擎。 看看Express是如何将Pug与Express集成的完美指南。</p>\n<p>在Express中，环境变量NODE_ENV旨在向Web应用程序通知执行环境：无论是在开发中还是在生产中。 Express和Pug自动修改生产环境中的几个选项的默认值，为用户提供更好的开箱即用体验。 具体来说，当process.env.NODE_ENV设置为“production”，Pug与Express一起使用时，compileDebug选项默认为false，而cache选项为true。</p>\n<h2>API</h2>\n<h5>标签属性</h5>\n<ul>\n<li>id,class写法</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n  p.title class写法1\n  p(class=&#x27;title&#x27;) class写法2\n  p#tit id写法1\n  p(id=&#x27;tit2&#x27;) id写法2     \n  \n&#x2F;&#x2F; 编译后\n  &lt;p class=&quot;title&quot;&gt;class写法1&lt;&#x2F;p&gt;\n  &lt;p class=&quot;title&quot;&gt;class写法2&lt;&#x2F;p&gt;\n  &lt;p id=&quot;tit&quot;&gt;id写法&lt;&#x2F;p&gt;\n  &lt;p id=&quot;tit2&quot;&gt;id写法2 &lt;&#x2F;p&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var classArr = [&#x27;small&#x27;,&#x27;medium&#x27;,&#x27;large&#x27;]\na(class= classArr)\na.test(class = classArr class=[&#x27;add&#x27;])\n\n&#x2F;&#x2F; 编译后\n&lt;a class=&quot;small medium large&quot;&gt;&lt;&#x2F;a&gt;\n&lt;a class=&quot;test small medium large add&quot;&gt;&lt;&#x2F;a&gt;\n</code></pre><p>它也可以是将类名映射到true或false值的对象.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;编译前\n- var active = &#x27;select&#x27;\na(class={active: active === &#x27;select&#x27;} )\n\n&#x2F;&#x2F; 编译后\n&lt;a class=&quot;active&quot;&gt;&lt;&#x2F;a&gt;\n</code></pre><ul>\n<li>其他属性\n通过()来依次编写属性,多个用逗号隔开.</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;编译前\na(class=&#x27;baidu&#x27; ,title=&#x27;baidu&#x27; href=&#x27;www.baidu.com&#x27;) 百度\n\n&#x2F;&#x2F;编译后\n&lt;a class=&quot;baidu&quot; title=&quot;baidu&quot; href=&quot;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n</code></pre><ul>\n<li>也支持所有正常的javascript表达式</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var flag  = true   &#x2F;&#x2F;注意这里使用变量要记得添加-符号.\nh2(class=flag ? &#x27;flag&#x27;: &#x27;&#x27;)\n\n&#x2F;&#x2F; 编译后\n&lt;h2 class=&quot;flag&quot;&gt;&lt;&#x2F;h2&gt;\n</code></pre><ul>\n<li>多个属性的另外写法</li>\n</ul>\n<p>其实就是换号缩进</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\na(\n      title=&#x27;baidu&#x27;,\n      href=&#x27;www.baidu.com&#x27;,\n      class=&#x27;links&#x27;\n)\n&#x2F;&#x2F; 编译后\n&lt;a class=&quot;links&quot; title=&quot;baidu&quot; href=&quot;www.baidu.com&quot;&gt;&lt;&#x2F;a&gt;\n</code></pre><p>如果您有一个非常长的属性，并且您的JavaScript运行时支持ES2015模板字符串，则可以使用该语法的属性：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ninput(data-json=&#96;\n      {\n        &quot;very-long&quot;: &quot;piece of &quot;,\n        &quot;data&quot;: true\n      }\n&#96;)\n&#x2F;&#x2F; 编译后\n&lt;input data-json=&quot;\n      {\n        &amp;quot;very-long&amp;quot;: &amp;quot;piece of &amp;quot;,\n        &amp;quot;data&amp;quot;: true\n      }\n&quot;&gt;\n</code></pre><ul>\n<li>引用属性</li>\n</ul>\n<p>如果你的属性名称包含了与JavaScript语法冲突的字符，请使用&quot;&quot;或’'引用，或使用逗号分隔不同的属性。</p>\n<p>官网举了个Angular 2的例子.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;(click)=&#x27;play()&#x27;,这里(click)会被当作一个函数调用而不是一个属性名字来解析.\n\n&#x2F;&#x2F; 编译前\ndiv(class=&#x27;div-class&#x27; (click)=&#x27;play()&#x27;)\n\n&#x2F;&#x2F; 编译后报错\ndiv(class=&#x27;div-class&#x27; (click)=&#x27;play()&#x27;)\n---------------------^\n</code></pre><p>正确写法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ndiv(class=&#x27;div-class&#x27; &#x27;(click)&#x27;=&#x27;play()&#x27;)\ndiv(class=&#x27;div-class&#x27;, (click) = &#x27;play()&#x27;)\n\n&#x2F;&#x2F; 编译后\n&lt;div class=&quot;div-class&quot; (click)=&quot;play()&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div class=&quot;div-class&quot; (click)=&quot;play()&quot;&gt;&lt;&#x2F;div&gt;\n</code></pre><ul>\n<li>属性插值</li>\n</ul>\n<p>以前版本的Pug / Jade支持如下插值语法(不再支持):</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F;编译前\n- var url = &#x27;www.baidu.com&#x27;\na(href=&#x27;&#x2F;#{url}&#x27;) links\n\n&#x2F;&#x2F;编译后 已不再支持\n&lt;a href=&quot;&#x2F;#{url}&quot;&gt;links&lt;&#x2F;a&gt;\n</code></pre><p>新的写法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var url = &#x27;demo.com&#x27;\na(href=&#x27;&#x2F;&#x27; + url) links\n- var url2 = &#x27;www.baidu.com&#x27;\na(href = url2 ) 百度  \n\n&#x2F;&#x2F; 编译后\n&lt;a href=&quot;&#x2F;demo.com&quot;&gt;links&lt;&#x2F;a&gt;\n&lt;a href=&quot;www.baidu.com&quot;&gt;百度  &lt;&#x2F;a&gt;\n</code></pre><p>如果你的javascript运行环境支持ES 2015.那么Pug支持模板字符串语法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var size1 = &#x27;small&#x27;\n- var size2 = &#x27;medium&#x27;\n- var size3 = &#x27;large&#x27;\nbutton(\n  type=&#x27;button&#x27;,\n  class=&#x27;btn btn-&#x27; + size1 + &#x27; &#x27; +  &#x27;btn-&#x27; + size2 + &#x27; &#x27; + &#x27;btn-&#x27; + size3\n)\nbutton(\n  type=&#x27;button&#x27;,\n  class=&#96;btn btn-$(size1) btn-$(size2) btn(size3)&#96;\n)\n&#x2F;&#x2F; 编译后\n&lt;button class=&quot;btn btn-small btn-medium btn-large&quot; type=&quot;button&quot;&gt;&lt;&#x2F;button&gt;\n&lt;button class=&quot;btn btn-small btn-medium btn-large&quot; type=&quot;button&quot;&gt;&lt;&#x2F;button&gt;\n</code></pre><ul>\n<li>未转义属性</li>\n</ul>\n<p>默认情况下，会转义所有属性（用转义序列代替特殊字符），以防止诸如跨站点脚本之类的攻击。 如果必须需要使用特殊字符，可以使用！=而不是=。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ndiv(title=&quot;&lt;code&gt;&quot;)\ndiv(title!=&quot;&lt;code&gt;&quot;)\n\n&#x2F;&#x2F; 编译后\n&lt;div title=&quot;&amp;lt;code&amp;gt;&quot;&gt;&lt;&#x2F;div&gt;\n&lt;div title=&quot;&lt;code&gt;&quot;&gt;&lt;&#x2F;div&gt;\n</code></pre><ul>\n<li>布尔属性</li>\n</ul>\n<p>布尔属性由Pug镜像，并接受布尔值（true和false）。 当没有指定值时，默认为true。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\ninput(type=&#x27;radio&#x27; checked)\ninput(type=&#x27;radio&#x27; checked=true)\ninput(type=&#x27;radio&#x27; checked=false)\n    \n&#x2F;&#x2F; 编译后\n&lt;input type=&quot;radio&quot; checked&gt;\n&lt;input type=&quot;radio&quot; checked&gt;\n&lt;input type=&quot;radio&quot;&gt;\n</code></pre><ul>\n<li>style属性</li>\n</ul>\n<p>style属性可以是一个字符串（像任何普通属性），但它也可以是一个对象</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\np(style={fontSize: &#x27;14px&#x27;,color: &#x27;red&#x27;})\n\n&#x2F;&#x2F; 编译后\n&lt;p style=&quot;fontSize:14px;color:red;&quot;&gt;&lt;&#x2F;p&gt;\n</code></pre><h5>Case</h5>\n<p>case语句是JavaScript Switch语句的缩写，并采用以下形式：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var friendsNum = 4\n    case friendsNum\n      when 0\n        p you have not friend\n      when 1\n        p you has one friend\n      default\n        p you has #{friendsNum} friends    \n        \n&#x2F;&#x2F; 编译后\n&lt;p&gt;you has 4 friends    &lt;&#x2F;p&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var friendsNum = 1\n    case friendsNum\n      when 0\n      when 1\n        p you has one friend\n      default\n        p you has #{friendsNum} friends\n        \n&#x2F;&#x2F; 编译后\n&lt;p&gt;you has one friend&lt;&#x2F;p&gt;\n</code></pre><p>当然也支持break;</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n- var friendsNum = 0\n    case friendsNum\n      when 0\n        - break\n      when 1\n        p you has one friend\n      default\n        p you has #{friendsNum} friends\n        \n&#x2F;&#x2F; 编译后\n无内容\n</code></pre><p>也可以使用块扩展语法</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n  - var friendsNum = 1\n    case friendsNum\n      when 0\n      when 1: p you has one friend\n      default: p you has #{friendsNum} friends\n      \n&#x2F;&#x2F; 编译后\n&lt;p&gt;you has one friend&lt;&#x2F;p&gt;\n\n</code></pre><h5>Code</h5>\n<p>Pug可以在你的模板中编写内置的JavaScript代码。 有三种类型的代码。</p>\n<ul>\n<li>Unbuffered Code\n不直接添加任何的输出</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- for(var i = 0; i &lt; 3;i++)\n      li item\n      \n&#x2F;&#x2F; 编译后\n&lt;li&gt;item&lt;&#x2F;li&gt;\n&lt;li&gt;item&lt;&#x2F;li&gt;\n&lt;li&gt;item&lt;&#x2F;li&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n- var nameList = [&#x27;kobe&#x27;,&#x27;cpul&#x27;,&#x27;james&#x27;]\n      each item in nameList\n        li=item\n        \n&#x2F;&#x2F; 编译后\n\n&lt;li&gt;kobe&lt;&#x2F;li&gt;\n&lt;li&gt;cpul&lt;&#x2F;li&gt;\n&lt;li&gt;james&lt;&#x2F;li&gt;\n</code></pre><ul>\n<li>Buffered Code</li>\n</ul>\n<p>以=开头，并输出评估模板中JavaScript表达式的结果。 为了安全起见，首先HTML被转义：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\np\n  = &#x27;this is code template &lt;code&gt;&#x27;\np= &#x27;this is code template&#x27; + &#x27;&lt;code&gt;&#x27;  \n\n&#x2F;&#x2F; 编译后\n\n&lt;p&gt;this is code template &amp;lt;code&amp;gt;\n&lt;&#x2F;p&gt;\n&lt;p&gt;this is code template&amp;lt;code&amp;gt;&lt;&#x2F;p&gt;\n</code></pre><ul>\n<li>Unescaped Buffered Code</li>\n</ul>\n<p>未转义的代码以！=开头，并输出评估模板中JavaScript表达式的结果。 这不会进行任何转义，所以对用户输入是不安全的：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\np\n  != &#x27;this is code template &lt;code&gt;&#x27;\np!= &#x27;this is code template&#x27; + &#x27;&lt;code&gt;&#x27;  \n\n&#x2F;&#x2F; 编译后\n&lt;p&gt;this is code template &lt;code&gt;\n&lt;&#x2F;p&gt;\n&lt;p&gt;this is code template&lt;code&gt;&lt;&#x2F;p&gt;\n</code></pre><h5>Comments注释</h5>\n<ul>\n<li>单行注释</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n&#x2F;&#x2F; 这是一个注释\np 这是一个注释\n\n&#x2F;&#x2F; 编译后\n\n&lt;!-- 这是一个注释--&gt;\n&lt;p&gt;这是一个注释&lt;&#x2F;p&gt;\n</code></pre><p>Pug还有种注释写法,只需添加连字符’-'即可。这些仅用于对Pug代码本身进行注释，编译后不会出现在HTML中。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n&#x2F;&#x2F;- 这是一个注释\np 这是一个注释\n    \n&#x2F;&#x2F; 编译后\n&lt;p&gt;这是一个注释&lt;&#x2F;p&gt;\n</code></pre><ul>\n<li>块级注释</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\n&#x2F;&#x2F;-\n  注释不会出现在模板中\n  真的\n&#x2F;&#x2F;\n  第一行注释\n  第二行注释\n      \n&#x2F;&#x2F; 编译后\n\n&lt;!--\n    第一行注释\n    第二行注释\n--&gt;\n</code></pre><ul>\n<li>条件注释</li>\n</ul>\n<p>对于条件注释，Pug没有任何特殊的语法，下面例子这是为旧版本的Internet Explorer添加后备标记的特殊方法，但是由于以&lt;开头的所有行被视为纯文本，普通的HTML样式条件注释将会很好。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n&lt;!--[if IE 8]&gt;\n&lt;p class=&quot;lt-ie9&quot;&gt;\n&lt;![endif]--&gt;\n    \n&#x2F;&#x2F; 编译后\n\n&lt;!--[if IE 8]&gt;\n&lt;p class=&quot;lt-ie9&quot;&gt;\n&lt;![endif]--&gt;\n\n</code></pre><h5>Conditionals条件语句</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var user = {name: &#x27;kobe&#x27;}\n- var flag = true\n#user\n  if user.name\n    h3.user-title #{user.name}\n  else if flag\n    p flag is #{flag}\n  else\n    p default   \n    \n&#x2F;&#x2F; 编译后\n&lt;div id=&quot;user&quot;&gt;\n  &lt;h3 class=&quot;user-title&quot;&gt;kobe&lt;&#x2F;h3&gt;\n&lt;&#x2F;div&gt;\n</code></pre><p>Pug也支持另外一个关键字 unless</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var user = {name: &#x27;kobe&#x27;}\n#user\n  unless !user.name\n  h2 #{user.name}\n\n\n&#x2F;&#x2F; 编译后\n&lt;div id=&quot;user&quot;&gt;\n  &lt;h2&gt;kobe&lt;&#x2F;h2&gt;\n&lt;&#x2F;div&gt;\n</code></pre><h5>doctype</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\ndoctype html\n\n&#x2F;&#x2F; 编译后\n\n&lt;!DOCTYPE html&gt;\n\n</code></pre><h5>Filters过滤器</h5>\n<p>过滤器可让你在Pug模板中使用其他语言。也就是支持插件的使用,通过插件对模板内容进行过滤,处理,输出.如scss,less,markdown,coffee-script…</p>\n<p>先全局安装这些插件</p>\n<pre class=\"prettyprint\"><code>npm install --save jstransformer-coffee-script\nnpm install --save jstransformer-markdown-it\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n\nh2 MarkDown\n  :markdown-it\n    #### this is markdown filter\n    [link](http:&#x2F;&#x2F;www.baidu.com)\n\n  :coffee-script\n    console.log(&#x27;this is coffee-script&#x27;);\n\n&#x2F;&#x2F; 编译后\n\n&lt;h2&gt;MarkDown&lt;&#x2F;h2&gt;&lt;h4&gt;this is markdown filter&lt;&#x2F;h4&gt;\n&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;www.baidu.com&quot;&gt;link&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;\n    (function() {\n  console.log(&#x27;this is coffee-script&#x27;);\n\n}).call(this);\n\n</code></pre><p>缺点:不能支持动态内容或选项。</p>\n<h5>Includes包含</h5>\n<p>Pug允许你静态包含一段 Jade, 或者别的存放在单个文件中的东西比如 CSS, HTML 非常常见的例子是包含头部和页脚。 假设我们有一个下面目录结构的文件夹：</p>\n<pre class=\"prettyprint\"><code>- &#x2F;index.jade\n- &#x2F;includes&#x2F;\n  -&#x2F;head.jade\n  -&#x2F;footer.jade\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\ndoctype html\nhtml\n  include includes&#x2F;header.jade\n  body\n    h1 这是主题内容\n    include includes&#x2F;footer.jade  \n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; header.jade\nheader\n  title 通用的header\n  script(src=&#x27;&#x2F;jQuery.js&#x27;)\n  link(href=&#x27;reset.css&#x27;)\n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; footer.jade\nfooter#footer\n  p Copyright (c) foobar\n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译后\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;header&gt;\n    &lt;title&gt;通用的header&lt;&#x2F;title&gt;\n    &lt;script src=&quot;&#x2F;jQuery.js&quot;&gt;&lt;&#x2F;script&gt;\n    &lt;link href=&quot;reset.css&quot;&gt;\n  &lt;&#x2F;header&gt;\n  &lt;body&gt;\n    &lt;h1&gt;这是主题内容&lt;&#x2F;h1&gt;\n    &lt;footer id=&quot;footer&quot;&gt;\n      &lt;p&gt;Copyright (c) foobar&lt;&#x2F;p&gt;\n    &lt;&#x2F;footer&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><p>include 可以包含比如 HTML 或者 CSS 这样的内容。给定一个扩展名后，Jade 不会把这个文件当作一个 Jade 源代码，并且会把它当作一个普通文本包含进来：</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 格式\n\nstyle\n  include style.css\nscript\n  include script.js  \n</code></pre><p>甚至可以通过include结合过滤器使用</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 引入article.md\ninclude:markdown-it article.md\n</code></pre><h5>模板继承</h5>\n<p>Jade 支持通过 block 和 extends 关键字来实现模板继承。 一个块就是一个 Jade 的 block ，它将在子模板中实现，同时是支持递归的。</p>\n<p>如果需要，Pug block 可以提供默认内容，但是可以通过block scripts, block content, 和 block foot来显示如下所示的可选项。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 基本使用\n\n&#x2F;&#x2F; 编译前\nblock desc\n  p 这是block context\nblock desc  \n  \n&#x2F;&#x2F; 编译后\n&lt;p&gt;这是block context&lt;&#x2F;p&gt;\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\n\ndoctype html\nhtml\n  include includes&#x2F;header.jade\n  body\n    block content\n    block foot\n    .footer  some footer content\n\n</code></pre><p>现在要继承上面那个index.jade，只需创建一个新文件，并使用extend指令，如下所示，给出路径。 您现在可以定义一个或多个block将覆盖父块内容的块.</p>\n<p>在Pug v1中，如果没有给定文件扩展名，那么.pug会自动附加到路径上，但是在Pug v2中，这个行为已被弃用。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; index.jade\n\ndoctype html\nhtml\n  block scripts\n    script(src=&#x27;&#x2F;jquery.js&#x27;)\n  body\n    block content\n    block foot\n    .footer  some footer content\n\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; page.jade\n\nextends index.jade\n\nblock scripts\n  script(src=&#x27;&#x2F;jquery.js&#x27;)\n  script(src=&#x27;&#x2F;page.js&#x27;)\n\nblock content\n  h2 page.jade\n  - var pets = [&#x27;cat&#x27;, &#x27;dog&#x27;]\n  each petName in pets\n    li=petName\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; page.jade 编译后\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;script src=&quot;&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src=&quot;&#x2F;page.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;body&gt;\n    &lt;h2&gt;page.jade&lt;&#x2F;h2&gt;\n    &lt;li&gt;cat&lt;&#x2F;li&gt;\n    &lt;li&gt;dog&lt;&#x2F;li&gt;\n    &lt;div class=&quot;footer&quot;&gt; some footer content&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><p>同样可以在一个子块里继续添加块，就像下面实现的块 content 里又定义了两个可以被实现的块 sidebar 和 primary，或者子模板直接实现 content。</p>\n<pre class=\"prettyprint\"><code>block content\n  .sidebar\n    block sidebar\n      p nothing\n  .primary\n    block primary\n      p nothing\n</code></pre><p>Pug允许你 替换 （默认）、 前置 和 追加 blocks. 使用 block append 或 block prepend 时 block 是可选的:</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; pageTwo.jade\n\nextend page.jade\n\nappend scripts\n  script(src=&#x27;&#x2F;pageTwo.js&#x27;)\n</code></pre><pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译后\n\n&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n  &lt;script src=&quot;&#x2F;jquery.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src=&quot;&#x2F;page.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;script src=&quot;&#x2F;pageTwo.js&quot;&gt;&lt;&#x2F;script&gt;\n  &lt;body&gt;\n    &lt;h2&gt;page.jade&lt;&#x2F;h2&gt;\n    &lt;li&gt;cat&lt;&#x2F;li&gt;\n    &lt;li&gt;dog&lt;&#x2F;li&gt;\n    &lt;div class=&quot;footer&quot;&gt; some footer content&lt;&#x2F;div&gt;\n  &lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><h5>Interpolation插值</h5>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var author = &#x27;xyz&#x27;\n- var date = &#x27;2017-4&#x27;\nh2\n  p writer was by #{author.toUpperCase()}\n  p date is #{date}\n\n&#x2F;&#x2F; 编译后\n\n&lt;h2&gt;\n  &lt;p&gt;writer was by XYZ&lt;&#x2F;p&gt;\n  &lt;p&gt;date is 2017-4&lt;&#x2F;p&gt;\n&lt;&#x2F;h2&gt;\n</code></pre><p>如果你想保持#{}插值符号,可以使用#{或者’’.</p>\n<h5>Iteration迭代</h5>\n<ul>\n<li>each</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var arr = [1,2,3,4]\neach val,index in arr\n  li= index + &#x27;:&#x27; + val \n\n&#x2F;&#x2F; 编译后\n\n&lt;li&gt;0:1&lt;&#x2F;li&gt;\n&lt;li&gt;1:2&lt;&#x2F;li&gt;\n&lt;li&gt;2:3&lt;&#x2F;li&gt;\n&lt;li&gt;3:4&lt;&#x2F;li&gt;\n\n</code></pre><ul>\n<li>while</li>\n</ul>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\n- var arr = 4\nwhile arr &gt; 0\n  li= arr--\n\n\n&#x2F;&#x2F; 编译后\n\n&lt;li&gt;4&lt;&#x2F;li&gt;\n&lt;li&gt;3&lt;&#x2F;li&gt;\n&lt;li&gt;2&lt;&#x2F;li&gt;\n&lt;li&gt;1&lt;&#x2F;li&gt;\n</code></pre><h5>Mixins</h5>\n<p>Mixins允许您创建可重用的Pug block。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin lists\n p this is a mixin block\n+lists\n+lists  \n\n&#x2F;&#x2F; 编译后\n\n&lt;p&gt;this is a mixin block&lt;&#x2F;p&gt;\n&lt;p&gt;this is a mixin block&lt;&#x2F;p&gt;\n</code></pre><p>mixins可以为一个带参数的函数</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin link(href,name)\n  a(href=href)= name\n\n+link(&#x27;www.baidu.com&#x27;,&#x27;百度&#x27;)  \n  \n&#x2F;&#x2F; 编译后\n\n&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;&#x2F;a&gt;\n</code></pre><p>mixins也可以使用一个block来作为内容</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin lists(names)\n p= &#x27;my name is &#x27; + names\n if block\n   block\n else\n   p not provided content\n+lists(&#x27;kobe&#x27;)\n+lists(&#x27;cpul&#x27;)\n  p block content\n\n&#x2F;&#x2F; 编译后\n\n&lt;p&gt;my name is kobe&lt;&#x2F;p&gt;\n&lt;p&gt;not provided content&lt;&#x2F;p&gt;\n&lt;p&gt;my name is cpul&lt;&#x2F;p&gt;\n&lt;p&gt;block content&lt;&#x2F;p&gt;\n</code></pre><p>未知数量参数(…)的mixins.</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\nmixin lists(className,...items)\n  ul(class=className)\n    each item in items\n      li= item\n\n+lists(&#x27;demo&#x27;,1,2,3)\n&#x2F;&#x2F; 编译后\n\n&lt;ul class=&quot;demo&quot;&gt;\n  &lt;li&gt;1&lt;&#x2F;li&gt;\n  &lt;li&gt;2&lt;&#x2F;li&gt;\n  &lt;li&gt;3&lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;\n</code></pre><h5>Tags</h5>\n<p>默认情况下，一行开头的文本（或仅在空格之后）代表一个html标签。 缩进的标签是嵌套的，创建了像html的树结构。</p>\n<p>Pug可以判断出哪些元素是自闭,您还可以通过简单地附加’/'字符来明确地自己关闭标签：</p>\n<p>为了节省空间，Pug提供嵌套标记的内联语法。</p>\n<pre class=\"prettyprint\"><code>&#x2F;&#x2F; 编译前\np: span 内联\n\n&#x2F;&#x2F; 编译后\n&lt;p&gt;&lt;span&gt;内联&lt;&#x2F;span&gt;&lt;&#x2F;p&gt;\n</code></pre><h2>Pug的缺点</h2>\n<p>凡事不可能完美.Pug也有自己的弊端.</p>\n<ul>\n<li>可移植性差</li>\n<li>对新手调试不方便</li>\n<li>性能不是很好</li>\n</ul>\n<h4>原文.<a href=\"https://github.com/1657413883/blog-notes/issues/81\">https://github.com/1657413883/blog-notes/issues/81</a></h4>\n</div>",
            "title": "之前学习整理的pug文档. 社区虽然也有,但是都是很久之前的.因此分享一下,希望对新人有用.",
            "last_reply_at": "2018-01-28T07:42:40.180Z",
            "good": false,
            "top": false,
            "reply_count": 4,
            "visit_count": 262,
            "create_at": "2018-01-27T11:59:22.775Z",
            "author": {
                "loginname": "1657413883",
                "avatar_url": "https://avatars3.githubusercontent.com/u/17512533?v=4&s=120"
            }
        }, {
            "id": "58c94ea659017af119c1d31b",
            "author_id": "54fed7b5c1749396754897ba",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>随着google translate api 的收费,有翻译需求的小伙伴都在与 google 斗智斗勇。</p>\n<p>网上流行一个翻译api，不需要获取google token，以get的方式调用。但大家都知道，get最大请求只有2048字符，远远不能满足小伙伴们的需求。那还有什么其他办法吗？难道真要去付费，楼主表示心在滴血！</p>\n<p>经过多次尝试，摸清了 google 翻译的规则，找出了token的计算方法。基于token能通过post方式调用翻译接口了，另外还基于爬虫抓取实现了网页翻译，解决了大多数的翻译需求。调用方法也超简单，不说了直接上代码。。。</p>\n<pre class=\"prettyprint language-javascript\"><code>\n  const translate = require(&#x27;translate-api&#x27;);\n\n  let transUrl = &#x27;https:&#x2F;&#x2F;nodejs.org&#x2F;en&#x2F;&#x27;;\n  translate.getPage(transUrl).then(function(htmlStr){\n    console.log(htmlStr.length)\n  });\n\n  let transText = &#x27;hello world!&#x27;;\n  translate.getText(transText,{to: &#x27;zh-CN&#x27;}).then(function(text){\n    console.log(text)\n  });\n\n\n</code></pre><p>示例项目： <a href=\"https://github.com/yixianle/google-translate\">https://github.com/yixianle/google-translate</a>\n在线演示： <a href=\"http://translate.hotcn.top/\">http://translate.hotcn.top/</a></p>\n</div>",
            "title": "给大家分享一个免费的谷歌翻译api",
            "last_reply_at": "2018-01-28T06:27:23.179Z",
            "good": false,
            "top": false,
            "reply_count": 9,
            "visit_count": 14186,
            "create_at": "2017-03-15T14:24:38.715Z",
            "author": {
                "loginname": "yixianle",
                "avatar_url": "https://avatars0.githubusercontent.com/u/11406512?v=4&s=120"
            }
        }, {
            "id": "596c55e4af1a22d018d97042",
            "author_id": "596c546b8f05de0819fdb25d",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/FkUaUJEGuq2fHJVLE-6mR0UiSWpr\" alt=\"QQ图片20170717141135.jpg\">\n从这里开始是我的nginx  nginx.conf的配置\n我需要怎么该这个配置呢？\n#user  nobody;\nworker_processes  2;</p>\n<p>#error_log  logs/error.log;\n#error_log  logs/error.log  notice;\n#error_log  logs/error.log  info;</p>\n<p>#pid        logs/nginx.pid;</p>\n<p>events {\nworker_connections  1024;\n}</p>\n<p>http {\ninclude       mime.types;\ndefault_type  application/octet-stream;</p>\n<pre class=\"prettyprint\"><code>#log_format  main  &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;\n#                  &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;\n#                  &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;;\n\n#access_log  logs&#x2F;access.log  main;\n\nsendfile        on;\n#tcp_nopush     on;\n\n#keepalive_timeout  0;\nkeepalive_timeout  65;\n\n#gzip  on;\n\nserver {\n    listen       80;\n    server_name  www.ycybl.com;\n\n    #charset koi8-r;\n\n    #access_log  logs&#x2F;host.access.log  main;\n\n    location &#x2F; {\n        root   html;\n        index  index.html index.htm;\n    }\n\n    #error_page  404              &#x2F;404.html;\n\n    # redirect server error pages to the static page &#x2F;50x.html\n    #\n    error_page   500 502 503 504  &#x2F;50x.html;\n    location = &#x2F;50x.html {\n        root   html;\n    }\n\n    # proxy the PHP scripts to Apache listening on 127.0.0.1:80\n    #\n    #location ~ \\.php$ {\n    #    proxy_pass   http:&#x2F;&#x2F;127.0.0.1;\n    #}\n\n    # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000\n    #\n    #location ~ \\.php$ {\n    #    root           html;\n    #    fastcgi_pass   127.0.0.1:9000;\n    #    fastcgi_index  index.php;\n    #    fastcgi_param  SCRIPT_FILENAME  &#x2F;scripts$fastcgi_script_name;\n    #    include        fastcgi_params;\n    #}\n\n    # deny access to .htaccess files, if Apache&#x27;s document root\n    # concurs with nginx&#x27;s one\n    #\n    #location ~ &#x2F;\\.ht {\n    #    deny  all;\n    #}\n}\n\n\n# another virtual host using mix of IP-, name-, and port-based configuration\n#\n#server {\n#    listen       8000;\n#    listen       somename:8080;\n#    server_name  somename  alias  another.alias;\n\n#    location &#x2F; {\n#        root   html;\n#        index  index.html index.htm;\n#    }\n#}\n\n\n# HTTPS server\n#\n#server {\n#    listen       443 ssl;\n#    server_name  localhost;\n\n#    ssl_certificate      cert.pem;\n#    ssl_certificate_key  cert.key;\n\n#    ssl_session_cache    shared:SSL:1m;\n#    ssl_session_timeout  5m;\n\n#    ssl_ciphers  HIGH:!aNULL:!MD5;\n#    ssl_prefer_server_ciphers  on;\n\n#    location &#x2F; {\n#        root   html;\n#        index  index.html index.htm;\n#    }\n#}\n</code></pre><p>}\nnginx.conf的配置结束</p>\n<p>我需要怎么该这个配置呢？</p>\n</div>",
            "title": "windows环境的服务器，部署nodejs，通过ngnix反向代理",
            "last_reply_at": "2018-01-28T01:41:31.885Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 1290,
            "create_at": "2017-07-17T06:15:00.570Z",
            "author": {
                "loginname": "newBird01",
                "avatar_url": "https://avatars3.githubusercontent.com/u/25924193?v=4&s=120"
            }
        }, {
            "id": "5a6cbcb89288dc81532882c8",
            "author_id": "5a4edbe8ebc575dc49b27157",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>原文：<a href=\"http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/\">http://holmeshe.me/understanding-react-js-source-code-initial-rendering-VI/</a></p>\n<p>HACKERNOON：<a href=\"https://hackernoon.com/understanding-the-react-source-code-vi-fe91ea58737f\">https://hackernoon.com/understanding-the-react-source-code-vi-fe91ea58737f</a></p>\n</div>",
            "title": "深入理解React源码 VI－英文预览版",
            "last_reply_at": "2018-01-27T17:54:00.557Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 269,
            "create_at": "2018-01-27T17:54:00.557Z",
            "author": {
                "loginname": "holmeshe",
                "avatar_url": "https://avatars3.githubusercontent.com/u/30769400?v=4&s=120"
            }
        }, {
            "id": "5a6c563ece45d44045146444",
            "author_id": "56276af03f017c2b49b41575",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>比如说 <a href=\"http://sf.gg\">http://sf.gg</a> 网站，直接用 superagent 请求到的是 301 跳转后的  <a href=\"https://segmentfault.com\">https://segmentfault.com</a> 的内容，我用 curl 命令获取 <a href=\"http://sf.gg\">http://sf.gg</a> 的内容如下：</p>\n<pre class=\"prettyprint\"><code>&lt;html&gt;\n&lt;head&gt;&lt;title&gt;301 Moved Permanently&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;\n&lt;body bgcolor=&quot;white&quot;&gt;\n&lt;center&gt;&lt;h1&gt;301 Moved Permanently&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;\n&lt;hr&gt;&lt;center&gt;nginx&#x2F;1.4.6 (Ubuntu)&lt;&#x2F;center&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;\n</code></pre><p>我希望得到 301 前也就是如上的内容，如何用 superagent 实现？\n看到 superagent 有个 <a href=\"http://visionmedia.github.io/superagent/#following-redirects\">Following redirects</a>，这个需求和这个有关系吗？有的话应该怎么用？搞了很久没实现</p>\n<p>望赐教，谢谢！</p>\n</div>",
            "title": "superagent 怎么请求到 301 跳转前的网页代码？",
            "last_reply_at": "2018-01-27T16:02:50.005Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 215,
            "create_at": "2018-01-27T10:36:46.174Z",
            "author": {
                "loginname": "hanzichi",
                "avatar_url": "https://avatars3.githubusercontent.com/u/10890665?v=4&s=120"
            }
        }, {
            "id": "5a6857b89288dc8153288136",
            "author_id": "53be3c03a3ccaece73ba0606",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h3>本着一种学习的态度写了此话题,如有不妥之处还请各位大牛多多指点.</h3>\n<p><strong>Purpose</strong>:   此解决方案,可以避免业务代码中出现大量的try/catch, 众所周知try/catch对性能方面有一定的影响,\n另一方面try/catch在Node.js &gt;= v8.3.0以后对性能的损耗是可以忽略不计的.</p>\n<blockquote>\n<p><a href=\"https://github.com/davidmarkclements/v8-perf\">try/catch具体文献: However for Node 8.3+ the performance hit of calling a function inside a try block is negligible.</a></p>\n</blockquote>\n<h4>1. try/catch方法处理异常</h4>\n<blockquote>\n<pre class=\"prettyprint language-js\"><code>async updateArticleById(ctx, next){\n\t\t let id = ctx.params[&quot;id&quot;];\n       let body = ctx.request.body;\n       try {\n           let ret = await Services.admin.updateArticle(id, body);\n           ctx.body = {ret: 0, data: ret};\n       } catch(e) {\n           ctx.body = {ret: 1, data: null, err: e.message || e.stack};\n       }\n}\n</code></pre></blockquote>\n<ul>\n<li>以上捕获异常是使用try/catch的方式来处理，因为await后面跟着的是Promise对象，当有异常的情况下会被Promise对象的内部</li>\n<li>catch捕获，而await就是一个then的语法糖，并不会捕获异常, 那就需要使用try/catch来捕获异常，并进行相应的逻辑处理。</li>\n</ul>\n<h4>2. 封装异常处理函数</h4>\n<ul>\n<li>知道了上面异常会被Promise对象自身的catch捕获异常，可以使用下面的解决方案\n<strong>to.js</strong></li>\n</ul>\n<blockquote>\n<pre class=\"prettyprint language-js\"><code>module.exports = (promise) =&gt; {\n   if(!promise || !Promise.prototype.isPrototypeOf(promise)){\n       return new Promise((resolve, reject)=&gt;{\n           reject(new Error(&quot;requires promises as the param&quot;));\n       }).catch((err)=&gt;{\n           return [err, null];\n       });\n   }\n   return promise.then(function(){\n       return [null, ...arguments];\n   }).catch(err =&gt; {\n       return [err, null];\n   });\n};\n</code></pre></blockquote>\n<blockquote>\n<p><strong>格式</strong>\n[error, …result]</p>\n</blockquote>\n<ul>\n<li>采用类似Golang风格的错误返回方式, 这里指定第一个参数为错误参数，后面为正常返回结果</li>\n<li>if块是用来处理非法参数，并返回错误[err, null]</li>\n<li>await后面如果是一个promise对象，那么await的任务就是在等待promise.resolve，而<strong>to.js</strong>就是主动去调用then和catch，主动处理并重新封装结果，并且在then或是catch里面继续返回封装后的数据，返回值对于await来说仍然是一个promise对象，然而resolve的值却是一个可迭代的对象[error, …result]</li>\n</ul>\n<blockquote>\n<p><strong>这个可迭代的对象如何使用 ?</strong></p>\n<pre class=\"prettyprint language-js\"><code>async updateArticleById(ctx, next){\n       let body = ctx.request.body;\n       let id = ctx.request.params[&quot;id&quot;];\n       let [err, ret] = await ctx.app.utils.to(Services.admin.updateArticleById(id, body));\n       if(err) {\n           return ctx.body = {ret: 1, data: null, err: err};\n       }\n\n       ctx.body = {ret: 0, data: ret};\n   }\n</code></pre></blockquote>\n<ul>\n<li><a href=\"http://blog.grossman.io/how-to-write-async-await-without-try-catch-blocks-in-javascript/\"><strong>参考</strong>:how-to-write-async-await-without-try-catch-blocks-in-javascript</a></li>\n</ul>\n</div>",
            "title": "async/await 如何优美的处理异常？",
            "last_reply_at": "2018-01-27T15:20:11.560Z",
            "good": false,
            "top": false,
            "reply_count": 20,
            "visit_count": 906,
            "create_at": "2018-01-24T09:54:00.151Z",
            "author": {
                "loginname": "danielsss",
                "avatar_url": "https://avatars3.githubusercontent.com/u/5127897?v=4&s=120"
            }
        }, {
            "id": "5a6c2348afa0a121784a906e",
            "author_id": "54009f5ccd66f2eb37190485",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p><img src=\"//dn-cnode.qbox.me/Fn19dYVwTT791QbjkJlLMDZ3SkpT\" alt=\"68747470733a2f2f692e696d6775722e636f6d2f5772664c45536d2e706e67.png\"></p>\n<p>这个图画的真是可圈可点，非常认可。还有后端和devops的，没这个好，地址 <a href=\"https://github.com/kamranahmedse/developer-roadmap\">https://github.com/kamranahmedse/developer-roadmap</a></p>\n</div>",
            "title": "Roadmap to becoming a web developer in 2018堪称经典",
            "last_reply_at": "2018-01-27T14:07:10.944Z",
            "good": false,
            "top": false,
            "reply_count": 1,
            "visit_count": 283,
            "create_at": "2018-01-27T06:59:20.313Z",
            "author": {
                "loginname": "i5ting",
                "avatar_url": "https://avatars3.githubusercontent.com/u/3118295?v=4&s=120"
            }
        }, {
            "id": "59421e4b325c502917ef09fa",
            "author_id": "52cce7827a15a38466a94b4b",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>一直想用Nodejs做点好玩的东西，感觉做爬虫是最简单的，于是参考其他大神的爬虫，学着写了一个。\n爬取目标选择的是cnBeta，因为每天一上班就要上去逛个把钟头，第一想到的爬取目标就是它了。\n功能实现就是最简单的保存新闻内容和图片，貌似西贝也没做什么防爬措施，因此没遇到特别大的困难，从一篇文章开始，异步取得关联文章id就可以实现连续爬取了，期间遇到个301跳转的问题，也很容易就解决了。</p>\n<p>完整代码见  <a href=\"https://github.com/tower1229/crawler\">Github</a>\n思路分析： <a href=\"http://refined-x.com/2017/06/09/Nodejs%E7%88%AC%E8%99%AB%E5%AE%9E%E8%B7%B5%E5%B0%8F%E8%AE%B0/\">Nodejs爬虫实践小记</a></p>\n</div>",
            "title": "学着做了一个Nodejs爬虫",
            "last_reply_at": "2018-01-27T08:46:03.189Z",
            "good": false,
            "top": false,
            "reply_count": 3,
            "visit_count": 1770,
            "create_at": "2017-06-15T05:42:35.244Z",
            "author": {
                "loginname": "tower1229",
                "avatar_url": "https://avatars1.githubusercontent.com/u/4016839?v=4&s=120"
            }
        }, {
            "id": "5a6bf0cf9d371d4a059eeeff",
            "author_id": "5720ab8c5a26c4a841ecbe17",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>各位大牛好！我想做一个商城的demo，前端用webpack+vue,后端是用koa2，数据库mongod。由于对node了解不深，选择遇到一个问题。先说说我的逻辑：\n\t\t\t我的mongo现在有2个表，一个是用户信息users,另一个是所有商品信息goods<img src=\"//dn-cnode.qbox.me/Fkr6pZ4HIZIRk4oQ3tcKguMhFprP\" alt=\"QQ截图20180127111023.png\">。因为我在添加商品的时候是没有把商品的价格存入用户的购物车列表里。现在我要展示购物车列表，当从数据库中查出用户users的购物车列表，想根据购物车列表的id再去查询商品列表goods所对应的商品信息。现在2个数据我都拿到了。然后想把商品列表goods里的商品价格拼接到用户购物车列表去，但是我怎么都添加不了。求大神解答。<img src=\"//dn-cnode.qbox.me/FpPpZVlxAkY-AFoMxfqJ_i_z5BoC\" alt=\"QQ截图20180127112153.png\">\n\t\t\t谢谢！</p>\n</div>",
            "title": "koa2怎么处理数据库查询回来的数据？",
            "last_reply_at": "2018-01-27T07:47:40.753Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 251,
            "create_at": "2018-01-27T03:23:59.885Z",
            "author": {
                "loginname": "lijianhu1",
                "avatar_url": "https://avatars1.githubusercontent.com/u/18611396?v=4&s=120"
            }
        }, {
            "id": "5a6a47119d371d4a059eee66",
            "author_id": "59f851ed6f151f46015df91f",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>价格不是问题，主要是想系统学习node，自己看东一榔头西一棒槌的。</p>\n</div>",
            "title": "北京求推荐一个好的node线下培训课程",
            "last_reply_at": "2018-01-27T06:26:10.450Z",
            "good": false,
            "top": false,
            "reply_count": 8,
            "visit_count": 483,
            "create_at": "2018-01-25T21:07:29.697Z",
            "author": {
                "loginname": "Orangem21",
                "avatar_url": "https://avatars0.githubusercontent.com/u/13641419?v=4&s=120"
            }
        }, {
            "id": "54b4d077edf686411e1b9d69",
            "author_id": "54446a734ca29a4d4c08c318",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h1>关于 node-odata</h1>\n<p>node-odata 可以让你轻松创建 REST API, 并能使用 <a href=\"http://www.odata.org/\">OData</a> 协议的格式进行数据的查询. 它让你可以更方便的创建 API 服务, 使你更专注于业务逻辑的处理.</p>\n<h2>什么是 OData 协议?</h2>\n<p>OData 全称开放数据协议(Open Data Protocol), 是一个用于 web 的数据访问协议. OData 提供了一个统一的 CRUD (create, read, update, and delete) 操作来查询和维护数据集.</p>\n<h2>为什么使用 node-odata?</h2>\n<p>node-odata 同时结合了 OData 强大的数据查询能力以及 NodeJS 高并发能力的优势, 使开发者能快速的创建一个高性能并支持各种复杂查询的 REST API.</p>\n<p>在常规的 REST 框架中, 仅仅提供了 REST 风格的 CRUD 操作. 开发者不的不对每一个资源都手动添加一些公共功能, 如排序/分页等, 甚至在复杂的业务场景中, 开发者不的不一次次根据业务需求制定一些特定的复杂查询, 这都极大的浪费了人力资源. OData数据访问协议很好的解决了这一问题. 它定义了$filter, $orderby, $select等一系列关键字来进行统一的筛选, 排序, 分页等操作. 极大的减轻了开发者的负担, 提高了生产力.</p>\n<p>反观 OData 社区, 目前 node-odata 是唯一一款基于 NodeJS 的 OData 实现. 与其它编译型语言的 OData 实现相比, 它运行更加高效, 部署更加方便, 编写更加简单 (最短只需3行代码即可初始化一个 OData 服务).</p>\n<h1>0) Demo</h1>\n<p>OData最大的特点就是他完全暴露的数据接口, 服务端只需要几行代码就能让客户端实现随心所欲的查询, 您可以试试:</p>\n<ul>\n<li>GET <a href=\"http://books.zackyang.com/odata/books\">/books</a></li>\n<li>GET [/books?$select=title, author](<a href=\"http://books.zackyang.com/odata/books?$select=title\">http://books.zackyang.com/odata/books?$select=title</a>, author)</li>\n<li>GET <a href=\"http://books.zackyang.com/odata/books?$top=3&amp;$skip=2\">/books?$top=3&amp;$skip=2</a></li>\n<li>GET [/books?$orderby=price desc](<a href=\"http://books.zackyang.com/odata/books?$orderby=price\">http://books.zackyang.com/odata/books?$orderby=price</a> desc)</li>\n<li>GET [/books?$filter=price gt 10](<a href=\"http://books.zackyang.com/odata/books?$filter=price\">http://books.zackyang.com/odata/books?$filter=price</a> gt 10)</li>\n<li>…</li>\n</ul>\n<p>很酷炫, 是吗? 你还可以任意组合查询条件, 以实现复杂查询. 比如:</p>\n<ul>\n<li>我想看看最贵的一本书是啥名字 GET [/books?$select=title&amp;$top=1&amp;orderby price desc](<a href=\"http://books.woshinidezhu.com/odata/books?$select=title\">http://books.woshinidezhu.com/odata/books?$select=title</a>, author)</li>\n<li>我想看看包含’Microsoft’关键字中, 按最便宜的排序 GET [/books?$filter=indexof(title,‘Microsoft’) ge 0 &amp;$orderby=price desc](<a href=\"http://books.woshinidezhu.com/odata/books?$filter=price\">http://books.woshinidezhu.com/odata/books?$filter=price</a> gt 10&amp;$orderby=price desc)</li>\n<li>…</li>\n</ul>\n<h1>1) 安装</h1>\n<p>node-odata 的运行需要依赖于 <a href=\"http://nodejs.org/\">NodeJS</a> 和 <a href=\"http://www.mongodb.org/\">MongoDB</a>, 在安装了依赖项之后, 运行以下命令即可:</p>\n<pre class=\"prettyprint\"><code>$ npm install node-odata\n</code></pre><h1>2) 快速开始</h1>\n<p>这里我们讲创建并运行一个最简单的 OData 服务.</p>\n<h2>2.1 创建服务</h2>\n<p>安装完成后, 新建 <em>index.js</em> 文件并输入:</p>\n<pre class=\"prettyprint\"><code>var odata = require(&#x27;node-odata&#x27;);\n\nodata.set(&#x27;db&#x27;, &#x27;mongodb:&#x2F;&#x2F;localhost&#x2F;my-app&#x27;);\n\nodata.resources.register({\n    url: &#x27;&#x2F;books&#x27;,\n    model: {\n        title: String,\n        price: Number\n    }\n});\n\nodata.listen(3000);\n</code></pre><h2>2.2 运行服务</h2>\n<p>保存后输入以下命令即可启动 OData 服务:</p>\n<pre class=\"prettyprint\"><code>$ node index.js\n</code></pre><p>它将自动注册以下路由:</p>\n<pre class=\"prettyprint\"><code>GET    &#x2F;odata&#x2F;books\nGET    &#x2F;odata&#x2F;books&#x2F;:id\nPOST   &#x2F;odata&#x2F;books\nPUT    &#x2F;odata&#x2F;books&#x2F;:id\nDELETE &#x2F;odata&#x2F;books&#x2F;:id\n</code></pre><p>(点击 <a href=\"http://tossshinhwa.github.io/node-odata/cn/\">这里</a> 查看完整文档)</p>\n<p>(查看 GitHub Page 请点击 <a href=\"https://github.com/TossShinHwa/node-odata\">这里</a>)</p>\n</div>",
            "title": "node-odata: 基于 NodeJS 的 REST 框架",
            "last_reply_at": "2018-01-27T05:30:34.257Z",
            "good": false,
            "top": false,
            "reply_count": 13,
            "visit_count": 4815,
            "create_at": "2015-01-13T07:59:51.938Z",
            "author": {
                "loginname": "TossShinHwa",
                "avatar_url": "https://avatars1.githubusercontent.com/u/3007674?v=4&s=120"
            }
        }, {
            "id": "5a606a26ce45d4404514611e",
            "author_id": "5909444b782dbc4b183ecfe2",
            "tab": "ask",
            "content": "<div class=\"markdown-text\"><p>早先写的博客，使用redux硬刚，现在要重构了.</p>\n<p>看到那么多redux的文件都怕…</p>\n<p>求推荐一个，既能复用redux的中间件，又不那么啰嗦的</p>\n<p><img src=\"http://i03.pictn.sogoucdn.com/e8eca196eeee8961\" alt></p>\n</div>",
            "title": "求推荐个基于redux的状态管理库，除了dva之外",
            "last_reply_at": "2018-01-27T03:53:11.280Z",
            "good": false,
            "top": false,
            "reply_count": 7,
            "visit_count": 518,
            "create_at": "2018-01-18T09:34:30.420Z",
            "author": {
                "loginname": "axetroy",
                "avatar_url": "https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"
            }
        }, {
            "id": "5a6bf4ccce45d44045146432",
            "author_id": "576a5d4063075514079b77e7",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><p>写了一份自己项目用的webpack配置文件放在博客上，欢迎参考\n<a href=\"https://www.liayal.com/article/5a5d770924f2803679a960e5\">https://www.liayal.com/article/5a5d770924f2803679a960e5</a></p>\n</div>",
            "title": "一份比较完整的webpack配置文件",
            "last_reply_at": "2018-01-27T03:41:00.802Z",
            "good": false,
            "top": false,
            "reply_count": 0,
            "visit_count": 350,
            "create_at": "2018-01-27T03:41:00.802Z",
            "author": {
                "loginname": "MaelWeb",
                "avatar_url": "https://avatars1.githubusercontent.com/u/7869311?v=4&s=120"
            }
        }, {
            "id": "5a6b6b94afa0a121784a9057",
            "author_id": "5909444b782dbc4b183ecfe2",
            "tab": "share",
            "content": "<div class=\"markdown-text\"><h3>WHY</h3>\n<p>对于经常造轮子的人来说，最痛苦的事莫过于配置开发环境。</p>\n<p>如果你构建一个纯粹的库，你可能需要ES6支持，那么你需要Babel，还需要安装Babel，然后根据需要的特性安装preset，安装plugins</p>\n<p>如果你需要构建一个React/Vue组件，那么就不是Babel那么简单，还需要配置Webpack。</p>\n<p>包括一堆的Loader，plugins，entry，output，devServer等等，不厌其烦…</p>\n<p>所以很迫切的需要一个零配置的开发工具，你看<a href=\"https://github.com/parcel-bundler/parcel\">parcel</a>不就是因为零配置备受推崇吗。</p>\n<p>所以，自己撸一个工具，configless是目标，专注于打包库/组件.</p>\n<pre class=\"prettyprint language-bash\"><code>npm install @axetroy&#x2F;libpack -g\n</code></pre><h3>构建一个Vue组件</h3>\n<pre class=\"prettyprint language-vue\"><code>&#x2F;&#x2F; index.vue\n&lt;template&gt;\n  &lt;div&gt;\n    &lt;h2&gt;Hello world&lt;&#x2F;h2&gt;\n    &lt;h2&gt;This is an Vue example component&lt;&#x2F;h2&gt;\n  &lt;&#x2F;div&gt;\n&lt;&#x2F;template&gt;\n\n&lt;script&gt;\nconsole.log(&quot;Load component&quot;);\nexport default {\n  name: &quot;index&quot;\n};\n&lt;&#x2F;script&gt;\n\n&lt;style scoped&gt;\n\n&lt;&#x2F;style&gt;\n</code></pre><pre class=\"prettyprint language-bash\"><code># -- externals 指明vue需要外部加载\nlibpack .&#x2F;index.vue .&#x2F;build --externals vue\n</code></pre><p>然后你还可以预览一下刚写的组件</p>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; main.js\nimport Vue from &quot;vue&quot;;\nimport App from &quot;.&#x2F;index.vue&quot;;\n\nnew Vue({\n  el: document.body,\n  render: h =&gt; h(App)\n});\n</code></pre><pre class=\"prettyprint language-bash\"><code>libpack .&#x2F;main.js .&#x2F;build --server\n</code></pre><p><a href=\"https://github.com/axetroy/libpack/tree/master/examples/vue-component\">完整代码</a></p>\n<h3>构建一个React组件</h3>\n<pre class=\"prettyprint language-jsx\"><code>&#x2F;&#x2F; index.jsx\nimport React, { Component } from &quot;react&quot;;\n\nclass Example extends Component {\n  render() {\n    return (\n      &lt;div&gt;\n        &lt;h2&gt;Hello world&lt;&#x2F;h2&gt;\n        &lt;h3&gt;This is an react example component&lt;&#x2F;h3&gt;\n      &lt;&#x2F;div&gt;\n    );\n  }\n}\n\nexport default Example;\n</code></pre><pre class=\"prettyprint language-bash\"><code># -- externals 指明react和react-dom需要外部加载\nlibpack .&#x2F;index.jsx .&#x2F;build --watch --externals react,react-dom\n</code></pre><p>然后你还可以预览一下刚写的组件</p>\n<pre class=\"prettyprint language-bash\"><code>libpack .&#x2F;app.jsx .&#x2F;build --server\n</code></pre><p><a href=\"https://github.com/axetroy/libpack/tree/master/examples/react-component\">完整代码</a></p>\n<h3>Typescript</h3>\n<pre class=\"prettyprint language-typescript\"><code>&#x2F;&#x2F; src&#x2F;index.ts\nclass Person {\n  say(word: string) {\n    console.log(&quot;hello &quot; + word);\n  }\n}\n\nnew Person().say(&quot;world&quot;);\n\n</code></pre><pre class=\"prettyprint language-bash\"><code>libpack .&#x2F;src&#x2F;index.ts .&#x2F;build\n</code></pre><p>typescript项目需要有tsconfig.json，如果项目目录不存在，那么会创建一个默认配置</p>\n<p><a href=\"https://github.com/axetroy/libpack/tree/master/examples/typescript\">完整代码</a></p>\n<h3>Flow</h3>\n<pre class=\"prettyprint language-flow\"><code>&#x2F;&#x2F; index.js\n&#x2F;&#x2F; @flow\nclass Person {\n  say(word: string) {\n    console.log(&quot;hello &quot; + word);\n  }\n}\n\nnew Person().say(&quot;world&quot;);\n\n</code></pre><pre class=\"prettyprint language-bash\"><code>libpack .&#x2F;index.js .&#x2F;build\n</code></pre><p><a href=\"https://github.com/axetroy/libpack/tree/master/examples/flow\">完整代码</a></p>\n<h3>Javascript</h3>\n<pre class=\"prettyprint language-javascript\"><code>&#x2F;&#x2F; index.js\nconsole.log(&quot;Hello world&quot;);\n\n&#x2F;&#x2F; generator\nfunction* generator() {\n  yield Promise.resolve();\n}\n\n&#x2F;&#x2F; async await\nasync function asyncFunction() {\n  await Promise.resolve();\n}\n\n&#x2F;&#x2F; dynamic import\nimport(&quot;.&#x2F;antoher&quot;);\n\n&#x2F;&#x2F; do expression\nfunction doExpression() {\n  let a = do {\n    if (x &gt; 10) {\n      (&quot;big&quot;);\n    } else {\n      (&quot;small&quot;);\n    }\n  };\n}\n\n&#x2F;&#x2F; Object rest spread\nlet { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };\nconsole.log(x); &#x2F;&#x2F; 1\nconsole.log(y); &#x2F;&#x2F; 2\nconsole.log(z); &#x2F;&#x2F; { a: 3, b: 4 }\n\n&#x2F;&#x2F; decorator\nfunction readable() {\n  return function() {};\n}\n\n@readable()\nclass Stream {}\n</code></pre><pre class=\"prettyprint language-bash\"><code>libpack .&#x2F;index.js .&#x2F;build\n</code></pre><p><a href=\"https://github.com/axetroy/libpack/tree/master/examples/javascript\">完整代码</a></p>\n<h3>最后</h3>\n<p><code>libpack</code>仅仅是一个内置了多个preset和plugins的Webpack配置，省去了配置的烦恼。</p>\n<p>你也不需要关心怎么配置es2015，es2016，es2017，也不用关心你能不能用新特性.</p>\n<p>撸起袖子就是干.</p>\n<p>欢迎各位大佬指教</p>\n<p>Github: <a href=\"https://github.com/axetroy/libpack\">https://github.com/axetroy/libpack</a></p>\n</div>",
            "title": "零配置无痛构建Javascript的库/组件",
            "last_reply_at": "2018-01-27T03:28:45.604Z",
            "good": false,
            "top": false,
            "reply_count": 2,
            "visit_count": 281,
            "create_at": "2018-01-26T17:55:32.023Z",
            "author": {
                "loginname": "axetroy",
                "avatar_url": "https://avatars2.githubusercontent.com/u/9758711?v=4&s=120"
            }
        }
    ]
}
